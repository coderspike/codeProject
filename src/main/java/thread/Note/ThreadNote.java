package thread.Note;

public class ThreadNote {
    /*
    一些基本概念：
    同步（synchronous）：等待方法返回
    和异步（asynchronous）：瞬间返回，但是并没有完成，是开启线程去做剩余的事情。

    并发（Concurrency）：有调度的过程
    并行（Parallelism）：两个线程同时进行（这两个概念不用特意区分，一般是一样的）
    临界区：
    进程---》进入区（申请区）---》进入阻塞队列---》临界区（需要不被多线程破坏）---》退出区

    阻塞（Blocking）：临界区之外做等待，操作系统层面被挂起
    非阻塞（Non-Blocking）：允许多个线程同时进入，保证不破坏数据

    死锁（Deadlock）：

    饥饿（Starvation）

    活锁（Livelock）

    并发级别
    – 阻塞
    当一个线程进入临界区后，其他线程必须等待

    – 无障碍（最弱的）
    无障碍是一种最弱的非阻塞调度
    自由出入临界区
    无竞争时，有限步内完成操作
    有竞争时，回滚数据

    – 无锁 （使用的比较广泛）
    是无障碍的
    保证有一个线程可以胜出
    while (!atomicVar.compareAndSet(localVar, localVar+1))
    {
     localVar = atomicVar.get();
    }

    – 无等待
    无锁的
    要求所有的线程都必须在有限步内完成
    无饥饿的
     */

    /*
    临界区:
    用来表示一种公共资源或者说是共享数据，可以被多个线程使用。但是每一次，只能有一个线程
    使用它，一旦临界区资源被占用，其他线程要想使用这个资源，就必须等待

    阻塞（Blocking）和非阻塞（Non-Blocking）
    – 阻塞和非阻塞通常用来形容多线程间的相互影响。比如一个线程占用了临界区资源，那么其它所有需要
    这个资源的线程就必须在这个临界区中进行等待，等待会导致线程挂起。这种情况就是阻塞。此时，如
    果占用资源的线程一直不愿意释放资源，那么其它所有阻塞在这个临界区上的线程都不能工作。
    – 非阻塞允许多个线程同时进入临界区
     */
}
