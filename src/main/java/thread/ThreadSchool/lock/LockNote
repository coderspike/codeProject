
1、公平锁/非公平锁
    公平锁是指多个线程按照申请锁的顺序来获取锁。
    非公平锁是指多个线程获取锁的顺序并不是按照申请锁的顺序，有可能后申请的线程比先申请的线程优先获取锁。
    有可能，会造成优先级反转或者饥饿现象。
    对于Java ReentrantLock而言，通过构造函数指定该锁是否是公平锁，默认是非公平锁。非公平锁的优点在于吞吐量比公平锁大。
    对于Synchronized而言，也是一种非公平锁。由于其并不像ReentrantLock是通过AQS的来实现线程调度，
    所以并没有任何办法使其变成公平锁。

2、可重入锁
    可重入锁的一个好处是可一定程度避免死锁
    锁的概念就不用多解释了,当某个线程A已经持有了一个锁,当线程B尝试进入被这个锁保护的代码段的时候.就会被阻塞.
    同一个线程再次进入同步代码的时候.可以使用自己已经获取到的锁,这就是可重入锁
    java里面内置锁(synchronize)和Lock(ReentrantLock)都是可重入的

    如果线程A继续再次获得这个锁呢?比如一个方法是synchronized,递归调用自己,那么第一次已经获得了锁,
    第二次调用的时候还能进入吗? 直观上当然需要能进入.这就要求必须是可重入的.可重入锁又叫做递归锁,再举个例子.

    public class Widget {
            public synchronized void doSomething() {
                ...
            }
    }

    public class LoggingWidget extends Widget {
            public synchronized void doSomething() {
                System.out.println(toString() + ": calling doSomething");
                super.doSomething();//若内置锁是不可重入的，则发生死锁
            }
    }

3、独享锁/共享锁
    独享锁是指该锁一次只能被一个线程所持有。
    共享锁是指该锁可被多个线程所持有。

    对于Java ReentrantLock而言，其是独享锁。但是对于Lock的另一个实现类ReadWriteLock，其读锁是共享锁，其写锁是独享锁。
    读锁的共享锁可保证并发读是非常高效的，读写，写读 ，写写的过程是互斥的。
    独享锁与共享锁也是通过AQS来实现的，通过实现不同的方法，来实现独享或者共享。
    对于Synchronized而言，当然是独享锁。

4、互斥锁/读写锁
    上面讲的独享锁/共享锁就是一种广义的说法，互斥锁/读写锁就是具体的实现。
    互斥锁在Java中的具体实现就是ReentrantLock
    读写锁在Java中的具体实现就是ReadWriteLock

5、乐观锁/悲观锁
    乐观锁与悲观锁不是指具体的什么类型的锁，而是指看待并发同步的角度。
    悲观锁认为对于同一个数据的并发操作，一定是会发生修改的，哪怕没有修改，也会认为修改。
    因此对于同一个数据的并发操作，悲观锁采取加锁的形式。悲观的认为，不加锁的并发操作一定会出问题。
    乐观锁则认为对于同一个数据的并发操作，是不会发生修改的。在更新数据的时候，会采用尝试更新，不断重新的方式更新数据。
    乐观的认为，不加锁的并发操作是没有事情的。

6、分段锁
    分段锁其实是一种锁的设计，并不是具体的一种锁，
    对于ConcurrentHashMap而言，其并发的实现就是通过分段锁的形式来实现高效的并发操作。

7、自旋锁
    （不适合锁住比较耗时的代码）
    通过自旋锁，可以减少线程阻塞造成的线程切换
    在Java中，自旋锁是指尝试获取锁的线程不会立即阻塞，
    而是采用循环的方式去尝试获取锁，这样的好处是减少线程上下文切换的消耗，缺点是循环会消耗CPU。
    自旋锁有以下特点：
    用于临界区互斥
    在任何时刻最多只能有一个执行单元获得锁
    要求持有锁的处理器所占用的时间尽可能短
    等待锁的线程进入忙循环

8、偏向锁/轻量级锁/重量级锁
    （CAS,compare and swap的缩写，中文翻译成比较并交换。）
    偏向锁是JDK 1.6提出的一种锁优化方式，其核心思想是如果程序没有竞争，则取消之前已经取得锁的线程的同步操作。
    也就是说，某一个锁被一个线程获取之后，便进入了偏向锁模式，当该线程再次这个锁时，就无需再进行相关的同步操作，
    从而节省了操作时间。但是如果在此期间，有其他线程申请了这个锁，则退出偏向锁模式。在JVM中可以使用

    轻量级锁是在无竞争的情况下使用CAS操作去取消除同步使用的互斥量。
    偏向锁是在无竞争的情况下 把整个同步都取消掉 ，连CAS操作都不做了。

    这三种锁是指锁的状态，并且是针对Synchronized。在Java 5通过引入锁升级的机制来实现高效Synchronized。这三种锁的状态是通过对象监视器在对象头中的字段来表明的。
    偏向锁是指一段同步代码一直被一个线程所访问，那么该线程会自动获取锁。降低获取锁的代价。
    轻量级锁是指当锁是偏向锁的时候，被另一个线程所访问，偏向锁就会升级为轻量级锁，其他线程会通过自旋的形式尝试获取锁，不会阻塞，提高性能。
    重量级锁是指当锁为轻量级锁的时候，另一个线程虽然是自旋，但自旋不会一直持续下去，当自旋一定次数的时候，还没有获取到锁，就会进入阻塞，该锁膨胀为重量级锁。重量级锁会让其他申请的线程进入阻塞，性能降低。