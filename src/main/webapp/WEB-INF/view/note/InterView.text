spring Core -基本核心类
    spring Bean -控制反转 依赖注入 等
    spring Aop  -aop特性（声明性的事务管理，日志的引入）
    Spring Context - 为核心提供大量扩展

Java事件委托机制：一个源产生一个事件时，把他送到一个或多个监听器那里，在这种机制种，监听器只是等待，一旦收到事件，处理事件并返回。
Java垃圾回收：是一种动态存储管理技术，它自动地释放不再被程序引用的对象，按照特定的垃圾收集算法来实现资源自动回收的功能。当一个对象不再被引用的时候，内存回收它占领的空间，以便空间被后来的新对象使用，以免造成内存泄露。
介绍一下Java NIO中的Buffer、Channel和Selector的概念和作用。
IO是面向流的，NIO是面向缓冲区的
NIO（Non-blocking I/O，在Java领域，也称为New I/O），是一种同步非阻塞的I/O模型
IO是以流的方式处理数据，而NIO是以块的方式处理数据。
Buffer和Channel是标准NIO中的核心对象
Buffer:
Buffer是一个对象，它包含一些要写入或读出的数据。在NIO中，数据是放入buffer对象的
关于Channel:
Channel是一个对象，可以通过它读取和写入数据。可以把它看做IO中的流。
Selector（选择器）是Java NIO的一个组件，能够检测一到多个NIO通道，并能够知晓通道是否为诸如读写事件做好准备。

Java IO的各种流是阻塞的。这意味着，当一个线程调用read() 或 write()时，该线程被阻塞，直到有一些数据被读取，或数据完全写入。该线程在此期间不能再干任何事情了。
Java NIO的非阻塞模式，使一个线程从某通道发送请求读取数据，但是它仅能得到目前可用的数据，如果目前没有数据可用时，就什么都不会获取。

基于字节操作的IO接口：InputStream和OutputStream
基于字符操作的IO接口：Reader和Writer
基于磁盘操作的IO接口：File
基于网络操作的IO接口：Socket

NIO（Non-blocking I/O，在Java领域，也称为New I/O），是一种同步非阻塞的I/O模型
NIO和IO有相同的作用和目的，但实现方式不同，NIO主要用到的是块[每一个操作都在一步中产生或消费一个数据块]，所以NIO的效率要比IO高很多。
在Java API中提供了两套NIO，一套是针对标准输入输出NIO，另一套就是网络编程NIO。
IO是以流的方式处理数据，而NIO是以块的方式处理数据。
Buffer和Channel是标准NIO中的核心对象

Buffer:
Buffer是一个对象，它包含一些要写入或读出的数据。在NIO中，数据是放入buffer对象的，
而在IO中，数据是直接写入或者读到Stream对象的。
应用程序不能直接对 Channel 进行读写操作，而必须通过 Buffer 来进行，即 Channel 是通过 Buffer 来读写数据的。


JVM
1、类加载器
类的加载指的是将类的.class文件中的二进制数据读入到内存中
2、执行引擎
3、运行时数据区
｛
共享区： 方法区 类信息
堆区 对象(由于现在的垃圾收集器都采用分代收集算法，所以堆空间还可以细分为新生代和老生代)
[类的加载的最终产品是位于堆区中的Class对象，Class对象封装了类在方法区内的数据结构，
并且向Java程序员提供了访问方法区内的数据结构的接口。]
非共享区：虚拟机栈 局部变量
本地方法栈 调用native方法
程序计数器
｝

类的加载过程:
加载-验证-准备-解析-初始化

内存分区:
线程共享数据区：
方法区：存储已被虚拟机加载的类信息、常量、静态变量、即时编译后代码等数据。
堆区：用于存放对象实例和数组。
线程私有数据区：
虚拟机栈：方法执行时创建一个栈帧，用于存储局部变量、操作数栈、动态链接、方法出口等消息。
本地方法栈：用于存放执行Native方法运行数据。
程序计数器：当前线程所执行字节码指示器，改变计数器指向选取下一条字节码指令。

JVM：
(1)类加载器，用来加载.class文件
(2)执行引擎，用来执行字节码文件或本地方法
(3)运行时数据区,包括堆、栈、方法区、程序计数器、本地方法栈

GC：
在JVM中，有一个垃圾回收线程，它是低优先级的，在正常情况下是不会执行的，只有在虚拟机空闲或者当前堆内存不足时，才会触发执行，
扫面那些没有被任何引用的对象，并将它们添加到要回收的集合中，进行回收。
我们常用的垃圾回收器一般都采用分代收集算法。把Java堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法。
在释放对象占用的内存之前，垃圾收集器会调用对象的finalize()方法。一般建议在该方法中释放对象持有的资源。

分代收集算法，“分代收集”（Generational Collection）算法，把Java堆分为新生代和老年代，
这样就可以根据各个年代的特点采用最适当的收集算法。

如何判断对象可以被回收？
判断对象是否存活一般有两种方式：
引用计数：每个对象有一个引用计数属性，新增一个引用时计数加1，引用释放时计数减1，计数为0时可以回收。此方法简单，无法解决对象相互循环引用的问题。
可达性分析（Reachability Analysis）：从GC Roots开始向下搜索，搜索所走过的路径称为引用链。当一个对象到GC Roots没有任何引用链相连时，则证明此对象是不可用的，不可达对象。
Dubbo是阿里巴巴提供的开源的SOA服务化治理的技术框架。
它最大的特点是按照分层的方式来架构，使用这种方式可以使各个层之间解耦合（或者最大限度地松耦合）。
从服务模型的角度来看，Dubbo采用的是一种非常简单的模型，要么是提供方提供服务，
要么是消费方消费服务，所以基于这一点可以抽象出服务提供方（Provider）和服务消费方（Consumer）两个角色。

1. Dubbo中zookeeper做注册中心，如果注册中心集群都挂掉，发布者和订阅者之间还能通信么？
可以通信的，启动dubbo时，消费者会从zk拉取注册的生产者的地址接口等数据，缓存在本地。每次调用时，
按照本地存储的地址进行调用；
注册中心对等集群，任意一台宕机后，将会切换到另一台；注册中心全部宕机后，服务的提供者和消费者仍能通过本地缓存通讯。
服务提供者无状态，任一台 宕机后，不影响使用；服务提供者全部宕机，服务消费者会无法使用，并无限次重连等待服务者恢复；

Redis，一个开源的 key-value，内存中的数据结构存储系统，它可以用作数据库、缓存和消息中间件。
RabbitMQ消息发送时，生产者是不知道消息是否发送到某个队列中去了，生产者仅仅只能将消息发送给某个交换器。
Broker
RabbbitMQ消息队列代理服务器实体。
Producer
发送消息的应用程序。
Consumer
接收消息的用户程序。
Exchange
交换器，生产者直接将消息发送给交换器。交换器将消息分发给指定的队列。它指定消息按什么规则，路由到哪个队列。
Binding
绑定，指的是交换器和队列之间的关系。它的作用就是把exchange和queue按照路由规则绑定起来。
Routing Key
路由关键字，exchange根据这个关键字进行消息投递。
vhost
虚拟主机，一个broker里可以开设多个vhost，用作不同用户的权限分离。
Channel
消息通道，包含了大量的API可用于编程。在客户端的每个连接里，可建立多个channel，每个channel代表一个会话任务。
Connection
在客户创建一个到某个虚拟主机的连接。
ConnectionFactory
连接工厂类。可以创建一个连接。


创建对象的几种方式
1 new的方式
2 newInstance的方式1
3 newInstance的方式2
4 范序列化 比如Jackson 、 Gson实现的json反序列化等

即便没有显示的声明，类的构造器实际上也是静态方法
1、getClass方法是一个final方法，不允许子类重写，并且也是一个native方法
2、hashCode方法也是一个native方法。该方法返回对象的哈希码，主要使用在哈希表中，比如JDK中的HashMap。
3、创建并返回当前对象的一份拷贝,Object类的clone方法是一个protected的native方法。由于Object本身没有实现Cloneable接口，
所以不重写clone方法并且进行调用的话会发生CloneNotSupportedException异常。
4、toString方法Object对象的默认实现，即输出类的名字@实例的哈希码的16进制。
5、notify方法final native。
6、跟notify一样，唯一的区别就是会唤醒在此对象监视器上等待的所有线程，而不是一个线程
7、wait方法 wait方法会让当前线程(我们先叫做线程T)将其自身放置在对象的等待集中
8、finalize方法该方法的作用是实例被垃圾回收器回收的时候触发的操作

Java 反序列化是指把字节序列恢复为 Java 对象的过程，ObjectInputStream 类的 readObject() 方法用于反序列化

final关键字
(1) 一个对象是常量，不代表不能转变对象的成员，仍可以其成员进行操作。
(2) 常量在使用前必须赋值，但除了在声明的同时初始化外，就只能在构造方法中初始化。
(3) final修饰的方法不能被重置（在子类中不能出现同名方法）。
(4) 如果声明一个类为final，则所有的方法均为final，无论其是否被final修饰，但数据成员可为final也可不是。


类的属性与方法可以使用static修饰符，用static修饰的属性与方法是该类的所有对象所共享的，它们可以直接通过类名去引用，在静态方法中只能引用该类的静态变量与静态方法，因为非静态的属性与方法在该类没有被实例化之前是不存在的，即没有相应的执行空间，为了使用的方便，我们可以把不依赖于类的属性
(即在方法中不对类的属性进行操作)的方法定义为静态的。

JVM在其内存空间开辟了一个称为“堆”的存储空间，这部分空间用于存储使用new关键字所创建的对象。

JVM在其内存空间开辟一个称为”栈”的存储空间，这部分空间用于存储程序运行时在方法中声明的所有的局部变量/

什么是方法区?
方法区用于存放类的信息，Java程序运行时，首先会通过类装载器载入类文件的字节码信息，经过解析后将其装入方法区。类的各种信息（包括方法）都在方法区存储.方法只有一份

static关键字
static关键字可以修饰成员变量，它所修饰的成员变量不属于对象的数据结构，而是属于类的变量，通常通过类名来引用static成员。 当创建对象后，成员变量是存储在堆中的，而static成员变量和类的信息一起存储在方法区, 而不是在堆中， 一个类的static成员变量只有“一份”（存储在方法区），无论该类创建了多少对象。

对象序列化概念?
对象是存在于内存中的。有时候我们需要将对象保存到硬盘上，又有时我们需要将对象传输到另一台计算机上等等这样的操作。这时我们需要将对象转换为一个字节序列，而这个过程就称为对象序列化。相反，我们有这样一个字节序列需要将其转换为对应的对象，这个过程就称为对象的反序列化。

Object:所有类的根类
对象的标识：hashCode()
对象的信息:toString()，默认情况下返回对象类型@地址信息
对象是否一样：equals,默认情况下根据地址比较相等。==比较的是对象的地址，而equals在语义上提供相等的含义


哪些情况下的对象会被垃圾回收机制处理掉
Java 垃圾回收机制最基本的做法是分代回收。内存中的区域被划分成不同的世代，对象根据其存活的时间被保存在对应世代的区域中。一般的实现是划分成3个世代：年轻、年老和永久。内存的分配是发生在年轻世代中的。当一个对象存活时间足够长的时候，它就会被复制到年老世代中。对于不同的世代可以使用不同的垃圾回收算法。进行世代划分的出发点是对应用中对象存活时间进行研究之后得出的统计规律。一般来说，一个应用中的大部分对象的存活时间都很短。比如局部变量的存活时间就只在方法的执行过程中。基于这一点，对于年轻世代的垃圾回收算法就可以很有针对性。

什么是多态？
①多态就是对象拥有多种形态：引用多态和方法多态。
②引用多态：父类的引用可以指向本类对象、父类的引用可以指向子类的对象。
③方法多态：创建本类对象时，调用的方法为本类的方法；创建子类对象时，调用的方法为子类重写的方法或者继承的方法。
④存在多态的必要条件：继承、重写。
⑤多态的作用是消除类型之间的耦合关系。

Object基类有哪些公用方法
clone、equals
hashCode
getClass
notify
notifyAll
toString
finalize方法：该方法用于释放资源。因为无法确定该方法什么时候被调用，很少使用。
wait方法：使当前线程等待该对象的锁，当前线程必须是该对象的拥有者，也就是具有该对象的锁。wait()方法一直等待，直到获得锁或者被中断。wait(long timeout)设定一个超时间隔，如果在规定时间内没有获得锁就返回。
调用该方法后当前线程进入睡眠状态，直到以下事件发生：
其他线程调用了该对象的notify方法
其他线程调用了该对象的notifyAll方法
其他线程调用了interrupt中断该线程
时间间隔到了,此时该线程就可以被调度了，如果是被中断的话就抛出一个InterruptedException异常

反射的用途
Java反射机制可以让我们在编译期(Compile Time)之外的运行期(Runtime)检查类，接口，变量以及方法的信息。反射还可以让我们在运行期实例化对象，调用方法，通过调用get/set方法获取变量的值。同时我们也可以通过反射来获取泛型信息，以及注解。还有更高级的应用--动态代理和动态类加载（ClassLoader.loadclass()）。
下面列举一些比较重要的方法：
getFields：获取所有 public 的变量。
getDeclaredFields：获取所有包括 private , protected 权限的变量。
setAccessible：设置为 true 可以跳过Java权限检查，从而访问private权限的变量。
getAnnotations：获取注解，可以用在类和方法上。

Lock 和 Synchronized 有什么区别？
使用方法的区别
Synchronized：在需要同步的对象中加入此控制，synchronized可以加在方法上，也可以加在特定代码块中，括号中表示需要锁的对象。
Lock：需要显示指定起始位置和终止位置。一般使用ReentrantLock类做为锁，多个线程中必须要使用一个ReentrantLock类做为对象才能保证锁的生效。且在加锁和解锁处需要通过lock()和unlock()显示指出。所以一般会在finally块中写unlock()以防死锁。
性能的区别

什么是值传递和引用传递？
对象被值传递，意味着传递了对象的一个副本。因此，就算是改变了对象副本，也不会影响源对象的值。
对象被引用传递，意味着传递的并不是实际的对象，而是对象的引用。因此，外部对引用对象所做的改变会反映到所有的对象上。



Spring 是如何管理事务的？
spring的事务声明有两种方式，编程式和声明式。spring主要是通过“声明式事务”的方式对事务进行管理，即在配置文件中进行声明，通过AOP将事务切面切入程序，最大的好处是大大减少了代码量。

选择使用Spring框架的原因?
使用Spring： 第一是使用它的IOC功能，在解耦上达到了配置级别。 第二是使用它对数据库访问事务相关的封装。 第三就是各种其他组件与Spring的融合，在Spring中更加方便快捷的继承其他一些组件。

Bean 是如何被管理的？
在Spring框架中，一旦把一个bean纳入到Spring
IoC容器之中，这个bean的生命周期就会交由容器进行管理，一般担当管理者角色的是BeanFactory或ApplicationContext。认识一下Bean的生命周期活动，对更好的利用它有很大的帮助。
概括来说主要有四个阶段：实例化，初始化，使用，销毁。

Spring MVC的核心流程是什么样的？
用户请求发送到前端控制器DispatcherServlet。
前端控制器DispatcherServlet接收到请求后，DispatcherServlet会使用HandlerMapping来处理，HandlerMapping会查找到具体进行处理请求的Handler对象。

HandlerMapping找到对应的Handler之后，并不是返回一个Handler原始对象，而是一个Handler执行链，在这个执行链中包括了拦截器和处理请求的Handler。
HandlerMapping返回一个执行链给DispatcherServlet。

DispatcherServlet接收到执行链之后，会调用Handler适配器去执行Handler。

Handler适配器执行完成Handler（也就是我们写的Controller）之后会得到一个ModelAndView，并返回给DispatcherServlet。

DispatcherServlet接收到Handler适配器返回的ModelAndView之后，会根据其中的视图名调用视图解析器。

视图解析器根据逻辑视图名解析成一个真正的View视图，并返回给DispatcherServlet。

DispatcherServlet接收到视图之后，会根据上面的ModelAndView中的model来进行视图中数据的填充，也就是所谓的视图渲染。
渲染完成之后，DispatcherServlet就可以将结果返回给用户了。


谈谈对Spring IoC的理解。
IoC不是什么技术，而是一种设计思想，它意味着将你设计好的对象交给容器控制，而不是传统的在你的对象内部直接控制。
IoC能做什么：把创建和查找依赖对象的控制权交给了容器，由容器进行注入组合对象，所以对象与对象之间是松散耦合，这样也方便测试，利于功能复用，更重要的是使得程序的整个体系结构变得非常灵活；IoC很好的体现了面向对象设计法则之一 –
好莱坞法则；
IoC和DI是同一个概念的不同角度描述，“依赖注入”明确描述了“被注入对象依赖IoC容器配置依赖对象”。
在Spring里，BeanFactory提供了IoC容器最基本功能，而 ApplicationContext 则增加了更多支持企业级功能支持

AOP
面向切面编程，在我们的应用中，经常需要做一些事情，但是这些事情与核心业务无关，比如，要记录所有update*方法的执行时间时间，操作人等等信息，记录到日志

选择使用Spring框架的原因?
使用Spring： 第一是使用它的IOC功能，在解耦上达到了配置级别。 第二是使用它对数据库访问事务相关的封装。
第三就是各种其他组件与Spring的融合，在Spring中更加方便快捷的继承其他一些组件。

如果多线程调用同一个对象的同一个方法，如果方法里无局部变量，那么不受任何影响；如果方法里有局部变量，只有读操作，不受影响；存在写操作，考虑多线程影响值。

Spring的事物管理主要分为编程式和声明式两种：
spring的事务是通过“声明式事务”的方式对事务进行管理，即在配置文件中进行声明，通过AOP将事务切面切入程序。最大的好处是大大减少了代码量

spring aop两种配置方式：
第一种：注解配置AOP（使用 AspectJ 类库实现的），大致分为三步：
1. 使用注解@Aspect来定义一个切面，在切面中定义切入点(@Pointcut),通知类型(@Before, @AfterReturning,@After,@AfterThrowing,@Around).
2. 开发需要被拦截的类。
3. 将切面配置到xml中，当然，我们也可以使用自动扫描Bean的方式。这样的话，那就交由Spring AoP容器管理

第二种：xml配置aop
实例同上：只是配置文件不同

spring 事务：
PROPAGATION_REQUIRED
如果当前没有事务，就新建一个事务，如果已经存在一个事务中，加入到这个事务中。这是最常见的选择。
spring事务控制放在service层，在service方法中一个方法调用service中的另一个方法，默认开启几个事务？
一个。
spring的事务传播方式默认是PROPAGATION_REQUIRED，也就是加入当前事务（如果没有就开启一个新事务）。
@Transactional(propagation=Propagation.REQUIRED)：默认的spring事务传播级别，使用该级别的特点是，如果上下文中已经存在事务，那么就加入到事务中执行，如果当前上下文中不存在事务，则新建事务执行，所以这个级别通常能满足处理大多数的业务场景。
7个传播级别

spring 什么情况下进行事务回滚(面试题)
spring事务回滚.默认情况,unchecked异常,即运行时异常runntimeException回滚事务;checked异常,即Exception可try{}捕获的不会回滚.当然也可配置spring参数让其回滚.
拦截器实现了 HandlerInterceptor接口
servlet filter和spring mvc Interceptor区别：
1.拦截器是基于java的反射机制的，而过滤器是基于函数回调。
2.拦截器不依赖与servlet容器，过滤器依赖与servlet容器。
3.拦截器只能对action请求起作用，而过滤器则可以对几乎所有的请求起作用。
4.拦截器可以访问action上下文、值栈里的对象，而过滤器不能访问。
5.在action的生命周期中，拦截器可以多次被调用，而过滤器只能在容器初始化时被调用一次。
6.拦截器可以获取IOC容器中的各个bean，而过滤器就不行，这点很重要，在拦截器里注入一个service，可以调用业务逻辑。

spring Core -基本核心类
spring Bean -控制反转 依赖注入 等
spring Aop  -aop特性（声明性的事务管理，日志的引入）
Spring Context - 为核心提供大量扩展

从注入方法上看，主要划分为三种类型：
构造函数注入
属性注入
接口注入
Spring 支持前两种

Spring事务管理器的接口是org.springframework.transaction.PlatformTransactionManager
事务的传播行为
事务的传播行为是指当事务方法被另一个事务方法调用时，必须指定事务应该如何传播。
例如：方法可能继续在现有事务中运行，也可能开启一个新事务，并在自己的事务中运行。Spring定义了七种传播行为：

（1）PROPAGATION_REQUIRED：
表示当前方法必须运行在事务中。如果当前事务存在，方法将会在该事务中运行。否则，会启动一个新的事务
注：以下具体讲解传播行为的内容参考自Spring事务机制详解
（2）PROPAGATION_SUPPORTS
如果存在一个事务，支持当前事务。如果没有事务，则非事务的执行。但是对于事务同步的事务管理器，PROPAGATION_SUPPORTS与不使用事务有少许不同。
（3）PROPAGATION_MANDATORY
如果已经存在一个事务，支持当前事务。如果没有一个活动的事务，则抛出异常。
（4）PROPAGATION_REQUIRES_NEW
总是开启一个新的事务。如果一个事务已经存在，则将这个存在的事务挂起。

（5）PROPAGATION_NOT_SUPPORTED
总是非事务地执行，并挂起任何存在的事务。使用PROPAGATION_NOT_SUPPORTED,也需要使用JtaTransactionManager作为事务管理器。（代码示例同上，可同理推出）

（6）PROPAGATION_NEVER
总是非事务地执行，如果存在一个活动事务，则抛出异常。

（7）PROPAGATION_NESTED
如果一个活动的事务存在，则运行在一个嵌套的事务中. 如果没有活动事务, 则按TransactionDefinition.PROPAGATION_REQUIRED 属性执行。这是一个嵌套事务,使用JDBC 3.0驱动时,仅仅支持DataSourceTransactionManager作为事务管理器。需要JDBC 驱动的java.sql.Savepoint类。有一些JTA的事务管理器实现可能也提供了同样的功能。使用PROPAGATION_NESTED，还需要把PlatformTransactionManager的nestedTransactionAllowed属性设为true;而 nestedTransactionAllowed属性值默认为false。
隔离级别
事务的第二个维度就是隔离级别（isolation level）。隔离级别定义了一个事务可能受其他并发事务影响的程度。
（1）并发事务引起的问题
在典型的应用程序中，多个事务并发运行，经常会操作相同的数据来完成各自的任务。并发虽然是必须的，但可能会导致一下的问题。

脏读（Dirty reads）
发生在一个事务读取了另一个事务改写但尚未提交的数据时。如果改写在稍后被回滚了，那么第一个事务获取的数据就是无效的。

不可重复读（Nonrepeatable read）
发生在一个事务执行相同的查询两次或两次以上，但是每次都得到不同的数据时。
这通常是因为另一个并发事务在两次查询期间进行了更新。

幻读（Phantom read）
与不可重复读类似。它发生在一个事务（T1）读取了几行数据，接着另一个并发事务（T2）插入了一些数据时。在随后的查询中，
第一个事务（T1）就会发现多了一些原本不存在的记录。
不可重复读与幻读的区别

几种隔离级别

ISOLATION_DEFAULT
使用后端数据库默认的隔离级别

ISOLATION_READ_UNCOMMITTED
最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读

ISOLATION_READ_COMMITTED
允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生

ISOLATION_REPEATABLE_READ
对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生

ISOLATION_SERIALIZABLE
最高的隔离级别，完全服从ACID的隔离级别，确保阻止脏读、不可重复读以及幻读，也是最慢的事务隔离级别，
因为它通常是通过完全锁定事务相关的数据库表来实现的

//    @Transactional(propagation= Propagation.REQUIRES_NEW,
//            isolation= Isolation.READ_COMMITTED,
//            noRollbackFor={UserAccountException.class},
//            readOnly=true, timeout=3)

数据库分表：
横向切分是指一个表数据量很大，分成非常多的小表进行存入等操作，比如股票行情数据，可以按照id取余进行分表存储
活跃度进行纵向分表比如博客系统中 标题等是冷数据，访问量等是热数据

索引的分类
聚集索引
非聚集索引
哈希索引
B+-树索引（二分查找）

哈希索引：
哈希索引查询效率O(1)
不能实现范围查找以及> < <> 等这些符号的相关查找
不需要频繁的调整数据分布

B-Tree索引：
支持范围查找
效率O(logN)
需要频繁的合并和分裂。

索引有什么作用
在数据库系统中建立索引主要有以下作用：
快速取数据；
保证数据记录的唯一性；
实现表与表之间的参照完整性；
在使用 ORDER BY、GROUP BY 子句进行数据检索时，利用索引可以减少排序和分组的时间。
我们想找到first_name为Chirstian的结果，下面比较一下加上索引前后查询所耗费的时间，从结果我们可以看出使用索引可以使查询效率提高20倍。

数据库分库分表策略
对于海量数据的数据库，如果是因为表多而数据多，这时候适合使用垂直切分，即把关系紧密（比如同一模块）的表切分出来放在一个server上。
如果表并不多，但每张表的数据非常多，这时候适合水平切分，即把表的数据按某种规则（比如按ID散列）切分到多个数据库(server)上。
MyBatis 包含一个非常强大的查询缓存特性,它可以非常方便地配置和定制。缓存可以极大的提升查询效率。
Mybatis的核心是：sqlsessionfactory

MyBatis系统中默认定义了两级缓存。
一级缓存和二级缓存。
1、默认情况下，只有一级缓存（SqlSession级别的缓存，也称为本地缓存）开启。
2、二级缓存需要手动开启和配置，他是基于namespace级别的缓存。
3、为了提高扩展性。MyBatis定义了缓存接口Cache。我们可以通过实现Cache接口来自定义二级缓存

sqlSession:每次访问数据库时都需要创建它
创建Sqlsession的地方只有一个，那就是SqlsessionFactory的openSession方法
一级缓存(local cache), 即本地缓存, 作用域默认为sqlSession。
当 Session flush 或 close 后, 该Session 中的所有 Cache 将被清空。

二级缓存(second level cache)，全局作用域缓存；二级缓存默认不开启，需要手动配置
MyBatis提供二级缓存的接口以及实现，缓存实现要求 POJO实现Serializable接口
二级缓存在 SqlSession 关闭或提交之后才会生效

Mybatis是如何进行分页的？分页插件的原理是什么？
Mybatis使用RowBounds对象进行分页，它是针对ResultSet结果集执行的内存分页，而非物理分页，
可以在sql内直接书写带有物理分页的参数来完成物理分页功能，也可以使用分页插件来完成物理分页。
(在我们自己的项目中是将分页信息封装到一个BasePageModel类中，包含page和rows属性，通过后台查询来分页)


<!--
<%--#{}和${}的区别是什么？--%>
<%--#{}是预编译处理，${}是字符串替换。--%>[记住这个就行了]
<%--Mybatis在处理#{}时，会将sql中的#{}替换为?号，调用PreparedStatement的set方法来赋值；--%>
<%--Mybatis在处理${}时，就是把${}替换成变量的值。--%>
<%--使用#{}可以有效的防止SQL注入，提高系统安全性。--%>
-->

<!--
当实体类中的属性名和表中的字段名不一样 ，怎么办 ？
第1种： 通过在查询的sql语句中定义字段名的别名，让字段名的别名和实体类的属性名一致
<select id=”selectorder” parametertype=”int” resultetype=”me.gacl.domain.order”>
    select order_id id, order_no orderno ,order_price price form orders where order_id=#{id};
</select>
第2种： 通过
<resultMap>来映射字段名和实体类属性名的一一对应的关系
    <select id="getOrder" parameterType="int" resultMap="orderresultmap">
        select * from orders where order_id=#{id}
    </select>
    <resultMap type=”me.gacl.domain.order” id=”orderresultmap”>
        <!–用id属性来映射主键字段–>
        <id property=”id” column=”order_id”>
            <!–用result属性来映射非主键字段，property为实体类属性名，column为数据表中的属性–>
            <result property=“orderno” column=”order_no”/>
                <result property=”price” column=”order_price”/>
    </reslutMap>
-->

分页：
1、在接口传入RowBounds对象即可
new RowBounds(count,pageNo,pageSize);
count:总记录数
pageNo:当前页
pageSize:每页记录数
mybatis自动在sql中加入分页(在mysql中加入limit)
2、pageHelper

MyBatis 编程步骤：
创建 SqlSessionFactory
通过 SqlSessionFactory 获取 SqlSession
通过 SqlSession 执行数据库操作
提交事务
关闭会话

MyBatis 是如何进行分页的？分页插件的原理？
mybatis 是通过 RowBounds 对象进行分页的，他针对返回结果集 ResultSet 进行内存分页，而非物理分页。
分页插件通过 mybatis 提供的分页插件接口进行实现，通过拦截器拦截需要执行的 sql 并重写 sql，
以此来添加对应的参数，最终实现分页效果

MyBatis 是否支持延迟加载？如果支持，他的实现原理是什么？
mybatis 支持延迟加载，但有限制。他支持一对一、一对多的延迟加载。
要使 mybatis 支持延迟加载，需要在配置文件中配置 lazyLoadingEnabled 值为 true。
mybatis 通过 CGLIB 创建目标对象的代理对象，在调用目标对象的 get
方法时，进行拦截并检查关联对象是否为空，
如果为空则调用 sql 进行相应对象的查询并通过 set 方法进行数据填充，最后在返回对应关联对象。
浅谈Memcached和Redis的区别
1、Redis不仅仅支持简单的k/v类型的数据，同时还提供list，set，zset，hash等数据结构的存储，Memcached基本只支持简单的key-value存储。
2、Redis支持数据的备份，即master-slave模式的数据备份。
3、Redis支持数据的持久化，可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用，Memcached不支持持久化。
多线程有什么用？
提高效率，重复操作的场景可以用多线程处理。

什么是线程安全？
就是当多线程进行访问的时候，采用加锁机制，当一个线程访问这个类的某个数据时，
进行保护， 其他线程不能进行访问直到该线程读取完毕，其他线程才可以使用。不会出现数据不一致或者数据污染。

了解多线程么？
实现多线程常用的两种方法分别是实现runnable接口和继承Thread类。因为java是单继承，所以实现Runnable接口的线程更灵活一些。
区别是实现Runnable的接口的线程可以共享操作数据。

线程有几种状态？
新建，就绪，运行，阻塞，死亡等

start()方法和Run()方法有什么区别？
start()方法会启动一个新的线程而run方法只会在原来线程中启动

wait和sleep()方法的区别？
wait方法释放锁，是object中的方法，一般与notify等共用，用于线程之间的交互。
sleep()方法来自Thread类，一般用于暂停执行，暂停期间依然保持对象锁。暂停过后恢复到就绪状态。
sleep()时间到了就变成就绪状态了必须传参。

线程池：在程序启动的时候就创建若干线程来响应处理。

线程的sleep()方法和yield()方法有什么区别？
线程执行sleep()方法后转入阻塞（blocked）状态，而执行yield()方法后转入就绪（ready）状态；

ThreadLocal和同步机制?
同步机制是为了同步多个线程对相同资源的并发访问，是为了多个线程之间进行通信的有效方式；
而ThreadLocal是隔离多个线程的数据共享，从根本上就不在多个线程之间共享资源（变量），这样当然不需要对多个线程进行同步了。

讲下join,yield方法的作用,以及什么场合用它们？
join() 的作用：让“主线程”等待“子线程”结束之后才能继续运行。
yield方法可以暂停当前正在执行的线程对象，让其它有相同优先级的线程执行。也有可能暂停后就马上再次执行。

notify(), wait()依赖于“同步锁”，而“同步锁”是对象锁持有，并且每个对象有且仅有一个！
这就是为什么notify(), wait()等函数定义在Object类，而不是Thread类中的原因。

Java中notify 和 notifyAll有什么区别？
notify()方法不能唤醒某个具体的线程，所以只有一个线程在等待的时候它才有用武之地。
而notifyAll()唤醒所有线程并允许他们争夺锁确保了至少有一个线程能继续运行。

多个线程之间如何协调？
wait()、notify()、notifyAll()：这三个方法用于协调多个线程对共享数据的存取，所以必须在同步语句块内使用。
wait方法要等待notify/notifyAll的线程释放锁后才能开始继续往下执行。

1 终止处于阻塞状态的线程
当线程由于被调用了sleep(), wait(), join()等方法而进入阻塞状态；若此时调用线程的interrupt()将线程的中断标记设为true。
由于处于阻塞状态，中断标记会被清除，同时产生一个InterruptedException异常。将InterruptedException放在适当的为止就能终止线程
2 中断运行状态下的线程
isInterrupted()是判断线程的中断标记是不是为true。当线程处于运行状态，并且我们需要终止它时；
可以调用线程的interrupt()方法，使用线程的中断标记为true，即isInterrupted()会返回true。此时，就会退出while循环。


java 中有两种线程：用户线程和守护线程。可以通过isDaemon()方法来区别它们：如果返回false，则说明该线程是“用户线程”；否则就是“守护线程”。
用户线程一般用户执行用户级任务，而守护线程也就是“后台线程”，一般用来执行后台任务。需要注意的是：Java虚拟机在“用户线程”都结束后会后退出。

为什么wait(), notify()和notifyAll()必须在同步方法或者同步块中被调用？
当一个线程需要调用对象的wait()方法的时候，这个线程必须拥有该对象的锁，
接着它就会释放这个对象锁并进入等待状态直到其他线程调用这个对象上的notify()方法。
同样的，当一个线程需要调用对象的notify()方法时，它会释放这个对象的锁，以便其他在等待的线程就可以得到这个对象锁。
由于所有的这些方法都需要线程持有对象的锁，这样就只能通过同步来实现，所以他们只能在同步方法或者同步块中被调用。

同步方法和同步块，哪个是更好的选择？
同步块是更好的选择，因为它不会锁住整个对象（当然你也可以让它锁住整个对象）。
同步方法会锁住整个对象，哪怕这个类中有多个不相关联的同步块，这通常会导致他们停止执行并需要等待获得这个对象上的锁。

volatile关键字在Java中有什么作用？
当我们使用volatile关键字去修饰变量的时候，所以线程都会直接读取该变量并且不缓存它。这就确保了线程读取到的变量是同内存中是一致的。

什么是死锁(Deadlock)？如何分析和避免死锁？
死锁是指两个以上的线程永远阻塞的情况，这种情况产生至少需要两个以上的线程和两个以上的资源。

一个线程池管理了一组工作线程，同时它还包括了一个用于放置等待执行的任务的队列。

volatile与synchronized
1）volatile本质是在告诉jvm当前变量在寄存器中的值是不确定的,需要从主存中读取,synchronized则是锁定当前变量,只有当前线程可以访问该变量,其他线程被阻塞住.
2）volatile仅能使用在变量级别,synchronized则可以使用在变量,方法.
3）volatile仅能实现变量的修改可见性,而synchronized则可以保证变量的修改可见性和原子性.
4）volatile不会造成线程的阻塞,而synchronized可能会造成线程的阻塞.

什么是原子操作？
检查数值、改变数值，以及可能发生的睡眠操作均作为单一的、不可分割的原子操作完成。

简述synchronized和java.util.concurrent.locks.Lock的异同？
主要相同点：Lock能完成synchronized所实现的所有功能
主要不同点：Lock有比synchronized更精确的线程语义和更好的性能。synchronized会自动释放锁，而Lock一定要求程序员手工释放，并且必须在finally从句中释放。

什么是竞态条件？你怎样发现和解决竞争？
当两个线程竞争同一资源时，如果对资源的访问顺序敏感，就称存在竞态条件。
在临界区中使用适当的同步就可以避免竞态条件。
界区实现方法有两种，一种是用synchronized，一种是用Lock显式锁实现。

你对线程优先级的理解是什么？
每一个线程都是有优先级的，一般来说，高优先级的线程在运行时会具有优先权，但这依赖于线程调度的实现，这个实现是和操作系统相关的(OSdependent)。
1、新建状态（New）：新创建了一个线程对象。
2、就绪状态（Runnable）：线程对象创建后，其他线程调用了该对象的start()方法。该状态的线程位于可运行线程池中，变得可运行，等待获取CPU的使用权。
3、运行状态（Running）：就绪状态的线程获取了CPU，执行程序代码。
4、阻塞状态（Blocked）：阻塞状态是线程因为某种原因放弃CPU使用权，暂时停止运行。直到线程进入就绪状态，才有机会转到运行状态。阻塞的情况分三种：
（一）、等待阻塞：运行的线程执行wait()方法，JVM会把该线程放入等待池中。(wait会释放持有的锁) （二）、同步阻塞：运行的线程在获取对象的同步锁时，若该同步锁被别的线程占用，则JVM会把该线程放入锁池中。
（三）、其他阻塞：运行的线程执行sleep()或join()方法，或者发出了I/O请求时，JVM会把该线程置为阻塞状态。当sleep()状态超时、join()等待线程终止或者超时、或者I/O处理完毕时，线程重新转入就绪状态。（注意,sleep是不会释放持有的锁）
5、死亡状态（Dead）：线程执行完了或者因异常退出了run()方法，该线程结束生命周期。

什么是线程池？为什么要使用它？为什么使用Executor框架比使用应用创建和管理线程好？
创建线程要花费昂贵的资源和时间，如果任务来了才创建线程那么响应时间会变长，而且一个进程能创建的线程数有限。
为了避免这些问题，在程序启动的时候就创建若干线程来响应处理，它们被称为线程池，里面的线程叫工作线程。
Executor框架让你可以创建不同的线程池。比如单线程池，每次处理一个任务；数目固定的线程池或者是缓存线程池（一个适合很多生存期短的任务的程序的可扩展线程池）。

如何创建一个Java线程池？
Java通过Executors提供四种线程池

为什么wait和notify方法要在同步块中调用？
主要是因为Java API强制要求这样做，如果你不这么做，你的代码会抛出IllegalMonitorStateException异常。还有一个原因是为了避免wait和notify之间产生竞态条件。
最主要的原因是为了防止以下这种情况
// 等待者(Thread1)
while (condition != true) { // step.1
lock.wait() // step.4
}
// 唤醒者(Thread2)
condition = true; // step.2
lock.notify(); // step.3
在对之前的代码去掉 synchronized 块之后，如果在等待者判断 condition != true 之后而调用 wait() 之前，唤醒者**将 condition 修改成了 true 同时调用了 notify()
**的话，那么等待者在调用了 wait() 之后就没有机会被唤醒了。

Java多线程中调用wait() 和 sleep()方法有什么不同？
Java程序中wait和sleep都会造成某种形式的暂停，它们可以满足不同的需要。
wait存在于Object类中；sleep存在于Thread类中。
wait会让出CPU资源以及释放锁；sleep只会释放CPU资源。
wait只能在同步块中使用；sleep没这限制。
wait需要notify（或 notifyAll）唤醒，进入等锁状态；sleep到指定时间便会自动恢复到运行状态。

volatile关键字在Java中有什么作用？
volatile是一个特殊的修饰符，只有成员变量才能使用它。
在Java并发程序缺少同步类的情况下，多线程对成员变量的操作对其它线程是透明的。
volatile变量可以保证下一个读取操作会在前一个写操作之后发生。

什么是ThreadLocal变量？
ThreadLocal是Java里一种特殊的变量。
每个线程都有一个ThreadLocal就是每个线程都拥有了自己独立的一个变量，竞争条件被彻底消除了。它是为创建代价高昂的对象获取线程安全的好方法，比如你可以用ThreadLocal让SimpleDateFormat变成线程安全的，因为那个类创建代价高昂且每次调用都需要创建不同的实例所以不值得在局部范围使用它，如果为每个线程提供一个自己独有的变量拷贝，将大大提高效率。
首先，通过复用减少了代价高昂的对象的创建个数。 其次，你在没有使用高代价的同步或者不变性的情况下获得了线程安全。
线程局部变量的另一个不错的例子是ThreadLocalRandom类，它在多线程环境中减少了创建代价高昂的Random对象的个数。

什么是死锁(Deadlock)？
死锁是指两个或两个以上的进程在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力作用，它们都将无法推进下去。

什么是乐观锁和悲观锁
悲观锁：假定会发生并发冲突，屏蔽一切可能违反数据完整性的操作。 乐观锁：假设不会发生并发冲突，只在提交操作时检查是否违反数据完整性。乐观锁不能解决脏读的问题。
1. 乐观锁是一种思想，具体实现是，表中有一个版本字段，第一次读的时候，获取到这个字段。处理完业务逻辑开始更新的时候，需要再次查看该字段的值是否和第一次的一样。如果一样更新，反之拒绝。之所以叫乐观，因为这个模式没有从数据库加锁。2.
悲观锁是读取的时候为后面的更新加锁，之后再来的读操作都会等待。这种是数据库锁乐观锁优点程序实现，不会存在死锁等问题。他的适用场景也相对乐观。阻止不了除了程序之外的数据库操作。
java 中有两种线程：用户线程和守护线程。可以通过isDaemon()方法来区别它们：如果返回false，则说明该线程是“用户线程”；
否则就是“守护线程”。用户线程一般用户执行用户级任务，而守护线程也就是“后台线程”，一般用来执行后台任务。
需要注意的是：Java虚拟机在“用户线程”都结束后会后退出。
interrupt()的作用是中断本线程。
1 终止处于阻塞状态的线程
当线程由于被调用了sleep(), wait(), join()等方法而进入阻塞状态；
若此时调用线程的interrupt()将线程的中断标记设为true。
由于处于阻塞状态，中断标记会被清除，同时产生一个InterruptedException异常。
将InterruptedException放在适当的为止就能终止线程
2 终止处于“运行状态”的线程
(01) 通过“中断标记”终止线程。
isInterrupted()是判断线程的中断标记是不是为true。当线程处于运行状态，并且我们需要终止它时；
可以调用线程的interrupt()方法，使用线程的中断标记为true，即isInterrupted()会返回true。此时，就会退出while循环。
(02) 通过“额外添加标记”。

组合使用interrupt方法与interruptted/isinterrupted方法终止正在运行的线程 + 抛异常法/Return法

interrupted() 和 isInterrupted()的区别
最后谈谈 interrupted() 和 isInterrupted()。
interrupted() 和 isInterrupted()都能够用于检测对象的“中断标记”。
区别是，interrupted()除了返回中断标记之外，它还会清除中断标记(即将中断标记设为false)；而isInterrupted()仅仅返回中断标记。

如果在sleep状态下停止某一线程，会进入catch语句，并且清除停止状态值，
使之变为false(调用isInterrupted()方法的结果是：false)。
使线程停止的方法：使用interrupt方法终止 正在阻塞中的 线程
join() 定义在Thread.java中。
join() 的作用：让“主线程”等待“子线程”结束之后才能继续运行。
为了判断线程是否属于终止状态
Thread.java类中提供了两种方法：
this.interrupted(): 测试当前线程是否已经中断，并清除中断状态（即上面提到的标识）；
this.isInterrupted(): 测试当前线程是否已经中断；


Java内存模型：
原子性
原子性是指一个操作是不可中断的。即使是在多个线程一起执行的时候，一个操作一旦开始，就
不会被其它线程干扰。
i++ 并不是一个原子操作
stop 已经不推荐使用 它会释放所有monitor 太暴力，可能导致数据异常
Happen-Before
 程序顺序原则：一个线程内保证语义的串行性
 volatile规则：volatile变量的写，先发生于读，这保证了volatile变量的可见性
 锁规则：解锁（unlock）必然发生在随后的加锁（lock）前
 传递性：A先于B，B先于C，那么A必然先于C
 线程的start()方法先于它的每一个动作
 线程的所有操作先于线程的终结（Thread.join()）
 线程的中断（interrupt()）先于被中断线程的代码
 对象的构造函数执行结束先于finalize()方法
ReentrantLock 重入锁  是同步锁的加强版
1.1.1. 可重入
单线程可以重复进入，但要重复退出
1.1.2. 可中断
lockInterruptibly()
1.1.3. 可限时
超时不能获得锁，就返回false，不会永久等待构成死锁
1.1.4. 公平锁
先来先得

一些基本概念：
同步（synchronous）：等待方法返回
和异步（asynchronous）：瞬间返回，但是并没有完成，是开启线程去做剩余的事情。

并发（Concurrency）：有调度的过程
并行（Parallelism）：两个线程同时进行（这两个概念不用特意区分，一般是一样的）
临界区：
进程---》进入区（申请区）---》进入阻塞队列---》临界区（需要不被多线程破坏）---》退出区

阻塞（Blocking）：临界区之外做等待，操作系统层面被挂起
非阻塞（Non-Blocking）：允许多个线程同时进入，保证不破坏数据

并发级别
– 阻塞
当一个线程进入临界区后，其他线程必须等待

– 无障碍（最弱的）
无障碍是一种最弱的非阻塞调度
自由出入临界区
无竞争时，有限步内完成操作
有竞争时，回滚数据

– 无锁 （使用的比较广泛）
是无障碍的
保证有一个线程可以胜出
while (!atomicVar.compareAndSet(localVar, localVar+1))
{
localVar = atomicVar.get();
}

– 无等待
无锁的
要求所有的线程都必须在有限步内完成
无饥饿的

临界区:
用来表示一种公共资源或者说是共享数据，可以被多个线程使用。但是每一次，只能有一个线程
使用它，一旦临界区资源被占用，其他线程要想使用这个资源，就必须等待

阻塞（Blocking）和非阻塞（Non-Blocking）
– 阻塞和非阻塞通常用来形容多线程间的相互影响。比如一个线程占用了临界区资源，那么其它所有需要
这个资源的线程就必须在这个临界区中进行等待，等待会导致线程挂起。这种情况就是阻塞。此时，如
果占用资源的线程一直不愿意释放资源，那么其它所有阻塞在这个临界区上的线程都不能工作。
– 非阻塞允许多个线程同时进入临界区

wait()的作用是让当前线程由“运行状态”进入“等待(阻塞)状态”的同时，也会释放同步锁。
而sleep()的作用是也是让当前线程由“运行状态”进入到“休眠(阻塞)状态”。
但是，wait()会释放对象的同步锁，而sleep()则不会释放锁。
sleep() 定义在Thread.java中。[时间到了就变成就绪状态了，和yield一样了]
sleep() 的作用是让当前线程休眠，即当前线程会从“运行状态”进入到“休眠(阻塞)状态”。sleep()会指定休眠时间，
线程休眠的时间会大于/等于该休眠时间；在线程重新被唤醒时，它会由“阻塞状态”变成“就绪状态”，从而等待cpu的调度执行。

sleep方法有什么作用,一般用来做什么？
sleep()方法（休眠）是线程类（Thread）的静态方法，调用此方法会让当前线程暂停执行指定的时间，
将执行机会（CPU）让给其他线程，
但是对象的锁依然保持，因此休眠时间结束后会自动恢复。注意这里的恢复并不是恢复到执行的状态，
而是恢复到可运行状态中等待CPU的宠幸。

线程的sleep()方法和yield()方法有什么区别？
① sleep()方法给其他线程运行机会时不考虑线程的优先级，因此会给低优先级的线程以运行的机会；
yield()方法只会给相同优先级或更高优先级的线程以运行的机会；
② 线程执行sleep()方法后转入阻塞（blocked）状态，而执行yield()方法后转入就绪（ready）状态；
③ sleep()方法声明抛出InterruptedException，而yield()方法没有声明任何异常；
④ sleep()方法比yield()方法（跟操作系统CPU调度相关）具有更好的可移植性。

请说出与线程同步以及线程调度相关的方法。
wait()：使一个线程处于等待（阻塞）状态，并且释放所持有的对象的锁[会释放锁]；
sleep()：使一个正在运行的线程处于睡眠状态，是一个静态方法，调用此方法要处理InterruptedException异常；
notify()：唤醒一个处于等待状态的线程，当然在调用此方法的时候，并不能确切的唤醒某一个等待状态的线程，
而是由JVM确定唤醒哪个线程，而且与优先级无关；
notityAll()：唤醒所有处于等待状态的线程，该方法并不是将对象的锁给所有线程，而是让它们竞争，
只有获得锁的线程才能进入就绪状态；

Java多线程中调用wait() 和 sleep()方法有什么不同？
Java程序中wait和sleep都会造成某种形式的暂停，它们可以满足不同的需要。
wait存在于Object类中；sleep存在于Thread类中。
wait会让出CPU资源以及释放锁；sleep只会释放CPU资源。
wait只能在同步块中使用；sleep没这限制。
wait需要notify（或 notifyAll）唤醒，进入等锁状态；sleep到指定时间便会自动恢复到运行状态。

synchronized几种用法
每个Java对象都可以用做一个实现同步的互斥锁，这些锁被称为内置锁。线程进入同步代码块或方法时自动获得内置锁，退出同步代码块或方法时自动释放该内置锁。进入同步代码块或者同步方法是获得内置锁的唯一途径。

实例同步方法
synchronized用于修饰实例方法（非静态方法）时，执行该方法需要获得的是该类实例对象的内置锁（同一个类的不同实例拥有不同的内置锁）。如果多个实例方法都被synchronized修饰，则当多个线程调用同一实例的不同同步方法（或者同一方法）时，需要竞争锁。但当调用的是不同实例的方法时，并不需要竞争锁。

静态同步方法
synchronized用于修饰静态方法时，执行该方法需要获得的是该类的class对象的内置锁（一个类只有唯一一个class对象）。调用同一个类的不同静态同步方法时会产生锁竞争。

同步代码块
synchronized用于修饰代码块时，进入同步代码块需要获得synchronized关键字后面括号内的对象（可以是实例对象也可以是class对象）的内置锁。

synchronized
– 指定加锁对象：对给定对象加锁，进入同步代码前要获得给定对象的锁。
– 直接作用于实例方法：相当于对当前实例加锁，进入同步代码前要获得当前实例的锁。
– 直接作用于静态方法：相当于对当前类加锁，进入同步代码前要获得当前类的锁。
当一个线程访问“某对象”的“synchronized方法”或者“synchronized代码块”时，其他线程对“该对象”的该“synchronized方法”或者“synchronized代码块”的访问将被阻塞。
下面是“synchronized代码块”对应的演示程序。
java.util.concurrent.ThreadPoolExecutor类是线程池中最核心的一个类
Executor：所有线程池的接口，只有一个方法
Executors：Executor 的工厂类，提供了创建各种不同线程池的方法，返回的线程池都实现了ExecutorService 接口
ThreadPoolExecutor：线程池的具体实现类，一般所有的线程池都是基于这个类实现的

CountDownLatch主要接口分析
CountDownLatch工作原理相对简单，可以简单看成一个倒计数器，在构造方法中指定初始值，
每次调用countDown()方法时将计数器减1，而await()会等待计数器变为0。CountDownLatch关键接口如下

countDown() 如果当前计数器的值大于1，则将其减1；若当前值为1，则将其置为0并唤醒所有通过await等待的线程；
若当前值为0，则什么也不做直接返回。
await() 等待计数器的值为0，若计数器的值为0则该方法返回；若等待期间该线程被中断，
则抛出InterruptedException并清除该线程的中断状态。
await(long timeout, TimeUnit unit) 在指定的时间内等待计数器的值为0，若在指定时间内计数器的值变为0，则该方法返回true；
若指定时间内计数器的值仍未变为0，则返回false；若指定时间内计数器的值变为0之前当前线程被中断，
则抛出InterruptedException并清除该线程的中断状态。
getCount() 读取当前计数器的值，一般用于调试或者测试。
CyclicBarrier可以译为循环屏障，也有类似的功能。
CyclicBarrier可以在构造时指定需要在屏障前执行await的个数，所有对await的调用都会等待，
直到调用await的次数达到预定指，所有等待都会立即被唤醒。
从使用场景上来说，CyclicBarrier是让多个线程互相等待某一事件的发生，然后同时被唤醒。
而上文讲的CountDownLatch是让某一线程等待多个线程的状态，然后该线程被唤醒。
AbstractQueuedSynchronizer，即队列同步器(aqs)

需要所有的子任务都完成时，才执行主任务，这个时候就可以选择使用CyclicBarrier。
赛跑时，等待所有人都准备好时，才起跑
barrier的await方法，在所有参与者都已经在此 barrier 上调用 await 方法之前，将一直等待。
而自从Java 1.5开始，就提供了Callable和Future，通过它们可以在任务执行完毕之后得到任务执行结果。
可以获取执行结果
Phaser适用场景
CountDownLatch和CyclicBarrier都是JDK 1.5引入的，而Phaser是JDK 1.7引入的。
Phaser的功能与CountDownLatch和CyclicBarrier有部分重叠，同时也提供了更丰富的语义和更灵活的用法。

CountDownLatch
CountDownLatch适用场景
Java多线程编程中经常会碰到这样一种场景——某个线程需要等待一个或多个线程操作结束（或达到某种状态）才开始执行。
比如开发一个并发测试工具时，主线程需要等到所有测试线程均执行完成再开始统计总共耗费的时间，
此时可以通过CountDownLatch轻松实现。
基础类型变量自增（i++）是一种常被新手误以为是原子操作而实际不是的操作。
Java中提供了对应的原子操作类来实现该操作，并保证原子性，其本质是利用了CPU级别的CAS指令。
由于是CPU级别的指令，其开销比需要操作系统参与的锁的开销小


Phaser顾名思义，与阶段相关。Phaser比较适合这样一种场景，一种任务可以分为多个阶段，现希望多个线程去处理该批任务，
对于每个阶段，多个线程可以并发进行，但是希望保证只有前面一个阶段的任务完成之后才能开始后面的任务。
这种场景可以使用多个CyclicBarrier来实现，每个CyclicBarrier负责等待一个阶段的任务全部完成。
但是使用CyclicBarrier的缺点在于，需要明确知道总共有多少个阶段，同时并行的任务数需要提前预定义好，且无法动态修改。
而Phaser可同时解决这两个问题。
// 只能5个线程同时访问
final Semaphore semp = new Semaphore(5);
SimpleDateFormat 不安全
stringBuffer 安全
stringBuilder 不安全
CopyOnWriteArrayList 安全
CopyOnWriteArraySet 安全
ConcurrentSkipListMap 安全
ConcurrentSkipListSet 安全
volatile 不具备原子性 不适合++场景，适合做全局判断如

Java如何保证可见性
Java提供了volatile关键字来保证可见性。当使用volatile修饰某个变量时，它会保证对该变量的修改会立即被更新到内存中，
并且将其它缓存中对该变量的缓存设置成无效，因此其它线程需要读取该值时必须从主内存中读取，从而得到最新的值。

Java中可通过volatile在一定程序上保证顺序性，另外还可以通过synchronized和锁来保证顺序性。

volatile变量规则：对一个被volatile修饰的写操作先发生于后面对该变量的读操作
信号量Semaphore
信号量维护一个许可集，可通过acquire()获取许可（若无可用许可则阻塞），通过release()释放许可，
从而可能唤醒一个阻塞等待许可的线程。

与互斥锁类似，信号量限制了同一时间访问临界资源的线程的个数，并且信号量也分公平信号量与非公平信号量。
而不同的是，互斥锁保证同一时间只会有一个线程访问临界资源，而信号量可以允许同一时间多个线程访问特定资源。
所以信号量并不能保证原子性。

信号量的一个典型使用场景是限制系统访问量。每个请求进来后，处理之前都通过acquire获取许可，若获取许可成功则处理该请求，
若获取失败则等待处理或者直接不处理该请求。
重入锁
Java中的重入锁（即ReentrantLock）与Java内置锁一样，是一种排它锁。
使用synchronized的地方一定可以用ReentrantLock代替。
重入锁需要显示请求获取锁，并显示释放锁。为了避免获得锁后，没有释放锁，而造成其它线程无法获得锁而造成死锁，
一般建议将释放锁操作放在finally块里，如下所示。
如果重入锁已经被其它线程持有，则当前线程的lock操作会被阻塞。除了lock()方法之外，重入锁（或者说锁接口）
还提供了其它获取锁的方法以实现不同的效果。

lockInterruptibly() 该方法尝试获取锁，若获取成功立即返回；若获取不成功则阻塞等待。与lock方法不同的是，在阻塞期间，
如果当前线程被打断（interrupt）则该方法抛出InterruptedException。该方法提供了一种解除死锁的途径。

tryLock() 该方法试图获取锁，若该锁当前可用，则该方法立即获得锁并立即返回true；若锁当前不可用，则立即返回false。
该方法不会阻塞，并提供给用户对于成功获利锁与获取锁失败进行不同操作的可能性。

tryLock(long time, TimeUnit unit) 该方法试图获得锁，若该锁当前可用，则立即获得锁并立即返回true。若锁当前不可用，则等待相应的时间（由该方法的两个参数决定）：
1）若该时间内锁可用，则获得锁，并返回true；
2）若等待期间当前线程被打断，则抛出InterruptedException；
3）若等待时间结束仍未获得锁，则返回false。

重入锁可定义为公平锁或非公平锁，默认实现为非公平锁。
公平锁是指多个线程获取锁被阻塞的情况下，锁变为可用时，最新申请锁的线程获得锁.

非公平锁是指多个线程等待锁的情况下，锁变为可用状态时，哪个线程获得锁是随机的。synchonized相当于非公平锁。
可通过在重入锁的构造方法中传入false或者使用无参构造方法构建非公平锁。
一个ReentrantReadWriteLock实例包含一个ReentrantReadWriteLock.ReadLock实例和一个ReentrantReadWriteLock.WriteLock实例。
通过readLock()和writeLock()方法可分别获得读锁实例和写锁实例，并通过Lock接口提供的获取锁方法获得对应的锁。
读写锁的锁定规则如下：
获得读锁后，其它线程可获得读锁而不能获取写锁
获得写锁后，其它线程既不能获得读锁也不能获得写锁

1、公平锁/非公平锁
公平锁是指多个线程按照申请锁的顺序来获取锁。
非公平锁是指多个线程获取锁的顺序并不是按照申请锁的顺序，有可能后申请的线程比先申请的线程优先获取锁。
有可能，会造成优先级反转或者饥饿现象。
对于Java ReentrantLock而言，通过构造函数指定该锁是否是公平锁，默认是非公平锁。非公平锁的优点在于吞吐量比公平锁大。
对于Synchronized而言，也是一种非公平锁。由于其并不像ReentrantLock是通过AQS的来实现线程调度，
所以并没有任何办法使其变成公平锁。

2、可重入锁
可重入锁的一个好处是可一定程度避免死锁
锁的概念就不用多解释了,当某个线程A已经持有了一个锁,当线程B尝试进入被这个锁保护的代码段的时候.就会被阻塞.
同一个线程再次进入同步代码的时候.可以使用自己已经获取到的锁,这就是可重入锁
java里面内置锁(synchronize)和Lock(ReentrantLock)都是可重入的

如果线程A继续再次获得这个锁呢?比如一个方法是synchronized,递归调用自己,那么第一次已经获得了锁,
第二次调用的时候还能进入吗? 直观上当然需要能进入.这就要求必须是可重入的.可重入锁又叫做递归锁,再举个例子.

public class Widget {
public synchronized void doSomething() {
...
}
}

public class LoggingWidget extends Widget {
public synchronized void doSomething() {
System.out.println(toString() + ": calling doSomething");
super.doSomething();//若内置锁是不可重入的，则发生死锁
}
}

3、独享锁/共享锁
独享锁是指该锁一次只能被一个线程所持有。
共享锁是指该锁可被多个线程所持有。

对于Java ReentrantLock而言，其是独享锁。但是对于Lock的另一个实现类ReadWriteLock，其读锁是共享锁，其写锁是独享锁。
读锁的共享锁可保证并发读是非常高效的，读写，写读 ，写写的过程是互斥的。
独享锁与共享锁也是通过AQS来实现的，通过实现不同的方法，来实现独享或者共享。
对于Synchronized而言，当然是独享锁。

4、互斥锁/读写锁
上面讲的独享锁/共享锁就是一种广义的说法，互斥锁/读写锁就是具体的实现。
互斥锁在Java中的具体实现就是ReentrantLock
读写锁在Java中的具体实现就是ReadWriteLock

5、乐观锁/悲观锁
乐观锁与悲观锁不是指具体的什么类型的锁，而是指看待并发同步的角度。
悲观锁认为对于同一个数据的并发操作，一定是会发生修改的，哪怕没有修改，也会认为修改。
因此对于同一个数据的并发操作，悲观锁采取加锁的形式。悲观的认为，不加锁的并发操作一定会出问题。
乐观锁则认为对于同一个数据的并发操作，是不会发生修改的。在更新数据的时候，会采用尝试更新，不断重新的方式更新数据。
乐观的认为，不加锁的并发操作是没有事情的。

6、分段锁
分段锁其实是一种锁的设计，并不是具体的一种锁，
对于ConcurrentHashMap而言，其并发的实现就是通过分段锁的形式来实现高效的并发操作。

7、自旋锁
（不适合锁住比较耗时的代码）
通过自旋锁，可以减少线程阻塞造成的线程切换
在Java中，自旋锁是指尝试获取锁的线程不会立即阻塞，
而是采用循环的方式去尝试获取锁，这样的好处是减少线程上下文切换的消耗，缺点是循环会消耗CPU。
自旋锁有以下特点：
用于临界区互斥
在任何时刻最多只能有一个执行单元获得锁
要求持有锁的处理器所占用的时间尽可能短
等待锁的线程进入忙循环

8、偏向锁/轻量级锁/重量级锁
（CAS,compare and swap的缩写，中文翻译成比较并交换。）
偏向锁是JDK 1.6提出的一种锁优化方式，其核心思想是如果程序没有竞争，则取消之前已经取得锁的线程的同步操作。
也就是说，某一个锁被一个线程获取之后，便进入了偏向锁模式，当该线程再次这个锁时，就无需再进行相关的同步操作，
从而节省了操作时间。但是如果在此期间，有其他线程申请了这个锁，则退出偏向锁模式。在JVM中可以使用

轻量级锁是在无竞争的情况下使用CAS操作去取消除同步使用的互斥量。
偏向锁是在无竞争的情况下 把整个同步都取消掉 ，连CAS操作都不做了。

这三种锁是指锁的状态，并且是针对Synchronized。在Java 5通过引入锁升级的机制来实现高效Synchronized。这三种锁的状态是通过对象监视器在对象头中的字段来表明的。
偏向锁是指一段同步代码一直被一个线程所访问，那么该线程会自动获取锁。降低获取锁的代价。
轻量级锁是指当锁是偏向锁的时候，被另一个线程所访问，偏向锁就会升级为轻量级锁，其他线程会通过自旋的形式尝试获取锁，不会阻塞，提高性能。
重量级锁是指当锁为轻量级锁的时候，另一个线程虽然是自旋，但自旋不会一直持续下去，当自旋一定次数的时候，还没有获取到锁，就会进入阻塞，该锁膨胀为重量级锁。重量级锁会让其他申请的线程进入阻塞，性能降低。
thread 1和thread 2都只需获得读锁，因此它们可以并行执行。
而thread 3因为需要获取写锁，必须等到thread 1和thread 2释放锁后才能获得锁。
问：锁和synchronized为何能保证可见性？
答：根据JDK 7的Java doc中对concurrent包的说明，
一个线程的写结果保证对另外线程的读操作可见，只要该写操作可以由happen-before原则推断出在读操作之前发生。

问：既然锁和synchronized即可保证原子性也可保证可见性，为何还需要volatile？
答：synchronized和锁需要通过操作系统来仲裁谁获得锁，开销比较高，而volatile开销小很多。
因此在只需要保证可见性的条件下，使用volatile的性能要比使用锁和synchronized高得多。

问：既然锁和synchronized可以保证原子性，为什么还需要AtomicInteger这种的类来保证原子操作？
答：锁和synchronized需要通过操作系统来仲裁谁获得锁，开销比较高，而AtomicInteger是通过CPU级的CAS操作来保证原子性，开销比较小。
所以使用AtomicInteger的目的还是为了提高性能。

问：还有没有别的办法保证线程安全
答：有。尽可能避免引起非线程安全的条件——共享变量。如果能从设计上避免共享变量的使用，
即可避免非线程安全的发生，也就无须通过锁或者synchronized以及volatile解决原子性、可见性和顺序性的问题。

问：synchronized即可修饰非静态方式，也可修饰静态方法，还可修饰代码块，有何区别
答：synchronized修饰非静态同步方法时，锁住的是当前实例；synchronized修饰静态同步方法时，锁住的是该类的Class对象；
synchronized修饰静态代码块时，锁住的是synchronized关键字后面括号内的对象。
CountDownLatch是通过一个计数器来实现的，计数器的初始值为线程的数量。每当一个线程完成了自己的任务后，
计数器的值就会减1。当计数器值到达0时，它表示所有的线程已经完成了任务，然后在闭锁上等待的线程就可以恢复执行任务。
线程安全，线程封闭 ThreadLocal 安全好用，线程安全
ThreadLocal 内部是一个map key是线程名称  map的值是线程对象
ThreadLocal 通过隐式的在不同线程内创建独立实例副本避免了实例线程安全的问题
ExecutorService、Callable、Future对象都是属于Executor框架中的功能类 Executors类，
提供工厂方法用于创建线程池，返回的线程池都实现了ExecutorService接口 创建有返回值的线程 必须实现Callable接口，
无返回值的实现Runable接口
notify(), wait()依赖于“同步锁”，而“同步锁”是对象锁持有，并且每个对象有且仅有一个！
这就是为什么notify(), wait()等函数定义在Object类，而不是Thread类中的原因。

Java中notify 和 notifyAll有什么区别？
notify()方法不能唤醒某个具体的线程，所以只有一个线程在等待的时候它才有用武之地。
而notifyAll()唤醒所有线程并允许他们争夺锁确保了至少有一个线程能继续运行。

多个线程之间如何协调？
wait()、notify()、notifyAll()：这三个方法用于协调多个线程对共享数据的存取，所以必须在同步语句块内使用。
wait方法要等待notify/notifyAll的线程释放锁后才能开始继续往下执行。

不要在Thread实例上使用 wait()和notify()方法

等待在当前对象上的 wait队列
notifyAll 唤醒全部，然后所有线程去争抢。
wait(), notify()和notifyAll()如果不在同步范围内使用，就会抛出java.lang.IllegalMonitorStateException的异常
在Object.java中，定义了wait(), notify()和notifyAll()等接口。wait()的作用是让当前线程进入等待状态，同时，wait()也会让当前线程释放它所持有的锁。而notify()和notifyAll()的作用，则是唤醒当前对象上的等待线程；notify()是唤醒单个线程，而notifyAll()是唤醒所有的线程。

Object类中关于等待/唤醒的API详细信息如下：
notify()        -- 唤醒在此对象监视器上等待的单个线程。
notifyAll()     -- 唤醒在此对象监视器上等待的所有线程。
wait()          -- 让当前线程处于“等待(阻塞)状态”，“直到其他线程调用此对象的 notify() 方法或 notifyAll() 方法”，当前线程被唤醒(进入“就绪状态”)。
wait(long timeout)             -- 让当前线程处于“等待(阻塞)状态”，“直到其他线程调用此对象的 notify() 方法或 notifyAll() 方法，或者超过指定的时间量”，当前线程被唤醒(进入“就绪状态”)。
wait(long timeout, int nanos)  -- 让当前线程处于“等待(阻塞)状态”，“直到其他线程调用此对象的 notify() 方法或 notifyAll() 方法，或者其他某个线程中断当前线程，或者已超过某个实际时间量”，当前线程被唤醒(进入“就绪状态”)。

等待在当前对象上的 wait队列
notify 随机唤醒一个。
wait(long timeout)会让当前线程处于“等待(阻塞)状态”，“直到其他线程调用此对象的 notify() 方法或 notifyAll() 方法，或者超过指定的时间量”，当前线程被唤醒(进入“就绪状态”)。
下面的示例就是演示wait(long timeout)在超时情况下，线程被唤醒的情况。

yield()的作用是让步。它能让当前线程由“运行状态”进入到“就绪状态”，从而让其它具有相同优先级的等待线程获取执行权；
但是，并不能保证在当前线程调用yield()之后，其它具有相同优先级的线程就一定能获得执行权；也有可能是当前线程又进入到“运行状态

wait()的作用是让当前线程由“运行状态”进入“等待(阻塞)状态”的同时，也会释放同步锁。而yield()的作用是让步，它也会让当前线程离开“运行状态”。它们的区别是：
(01) wait()是让线程由“运行状态”进入到“等待(阻塞)状态”，而不yield()是让线程由“运行状态”进入到“就绪状态”。
(02) wait()是会线程释放它所持有对象的同步锁，而yield()方法不会释放锁。

“线程t1”在能被4整数的时候，并没有切换到“线程t2”。这表明，yield()虽然可以让线程由“运行状态”进入到“就绪状态”；
但是，它不一定会让其它线程获取CPU执行权(即，其它线程进入到“运行状态”)，即使这个“其它线程”与当前调用yield()的线程具有相同的优先级。
实现Runnable接口的话可以做到多个线程之间的资源共享
共享数据，应为创建Thread实例时，使用的是同一个MyRunnable类对象
start会直接启动一个新线程，并在新线程中运行run方法
Java不支持类的多重继承，但允许你调用多个接口。所以如果你要继承其他类，当然是调用Runnable接口好了。
实现多线程的两种方式:
1、实现Runnable 接口
2、继承Thread类
[在java.lang包中定义,继承此类必须重写run()方法]
public class Thread implements Runnable

区别：
1、Runnable 属于接口，所以可以有多个实现；Thread只有一个。
2、实现Runnable 的线程类，可以被多个线程实例共享数据[每个线程一份数据]。
[一个类只能有一个父类，但是可以实现多个接口，所以实现Runnable 有更好的扩展性，多个线程“资源共享”，建议使用这种方式]

线程有哪几种状态？
线程有新建，运行，就绪，阻塞，死亡等状态。
在一个线程完整的生命周期中，它可能经历五种状态：新建（New）、就绪（Runnable）、运行（Running）、阻塞（Blocked）、
终止（Zombie）

wait和sleep的不同？
wait()会释放对象的同步锁，而sleep()则不会释放锁。

在Java中什么是线程调度？
JVM调度的模式有两种：分时调度和抢占式调度。
分时调度是所有线程轮流获得CPU使用权，并平均分配每个线程占用CPU的时间;
抢占式调度是根据线程的优先级别来获取CPU的使用权。
JVM的线程调度模式采用了抢占式模式。既然是抢占调度，那么我们就能通过设置优先级来“有限”的控制线程的运行顺序，
注意“有限”一次。

线程池:
在程序启动的时候就创建若干线程来响应处理，它们被称为线程池，里面的线程叫工作线程。

在后台默默地完成一些系统性的服务，比如垃圾回收线程、JIT线程就可以理解为守护线程.
当一个Java应用内，只有守护线程时，Java虚拟机就会自然退出
Thread 是一个类。Thread本身就实现了Runnable接口[public class Thread implements Runnable {}]
Object类，定义了wait(), notify(), notifyAll()等休眠/唤醒函数。
Thread类，定义了一些列的线程操作函数。例如，sleep()休眠函数, interrupt()中断函数, getName()获取线程名称等。
sleep方法：
public static native void sleep(long millis) throws InterruptedException;
synchronized，是关键字；它区分为synchronized代码块和synchronized方法。synchronized的作用是让线程获取对象的同步锁。
多线程中的三个核心概念：
原子性：跟数据库事务的原子性概念差不多，即一个操作（有可能包含有多个子操作）要么全部执行（生效），
要么全部都不执行（都不生效）。
可见性：当多个线程并发访问共享变量时，一个线程对共享变量的修改，其它线程能够立即看到。
可见性问题是好多人忽略或者理解错误的一点。
顺序性：CPU虽然并不保证完全按照代码顺序执行，但它会保证程序最终的执行结果和代码顺序执行时的结果一致。

HashSet的add方法是如何实现的,如何去重的;
答案：
HashSet的底层是使用HashMap来实现的，调用add方法的时候，底层也是用HashMap的put方法来实现的。HashSet之所以具备去重的能力，
也是因为HashMap的put方法中，如果发现key已经存在了，会覆盖key对应的值，但是对于HashSet来说，还是原来那个key。也就是说Key set并没有任何变动。

数组:
array的父类是：class java.lang.Object
arrayList:
这是arrayList的继承关系
public class ArrayList<E> extends AbstractList<E>
    implements List<E>, RandomAccess, Cloneable, java.io.Serializable
    arrayList包含了两个重要的对象：elementData 和 size。
    elementData 是"Object[]类型的数组"
    size 则是动态数组的实际大小
    线程不安全，多线程解决方案：
    ArrayList不是线程安全的，只能在单线程环境下
    多线程环境下可以考虑用Collections.synchronizedList(List list)方法返回一个线程安全的ArrayList对象
    也可以使用concurrent并发包下的CopyOnWriteArrayList类。
    扩容方法：扩大1.5倍将原来的数组copy进新数组 默认容量为10
    List 和 Set都是继承自 Collection接口
    ArrayList相当于动态数组，默认容量为10
    List取值快(是因为数组有下标)，插入慢(是因为要整体移动别的元素)，支持随机访问,线程不安全。
    添加或删除一个元素需要移动数组中的其他元素,所以不适合频繁操作。这是ArrayList最大的缺点。
    当数据量大的时候很耗性能。
    适用于频繁的数据读取
    允许加入null元素，可以添加重复元素。

    ArrayList和LinkedList的区别?
    最明显的区别是 ArrrayList底层的数据结构是数组，支持随机访问，而 LinkedList 的底层数据结构是双向循环链表，
    不支持随机访问。
    使用下标访问一个元素，ArrayList 的时间复杂度是 O(1)，而 LinkedList 是 O(n)。

    ArrayList和Array有什么区别?
    Array可以容纳基本类型和对象，而ArrayList只能容纳对象。
    ArrayList 是Java集合框架类的一员,可以称它为一个动态数组. array 是静态的,所以一个数据一旦创建就无法更改他的大小

    如何实现集合排序?
    你可以使用有序集合，如 TreeSet 或 TreeMap，你也可以使用有顺序的的集合，如 list，然后通过 Collections.sort() 来排序。
    Collection是最基本的集合接口，一组Collection代表一组Object
    Collection接口是List、Set等集合高度抽象出来的接口，它包含了这些集合的基本操作，主要又分为两大部分：List和Set。
    Collection
    --List
    --Set
    Map
    --HashMap
    --TreeMap
    --LinkedHashMap
    一个实现了Comparable接口的类，可以让其自身的对象和其他对象进行比较。
    也就是说，同一个类的两个对象之间要想比较，对应的类就要实现Comparable接口，并实现compareTo()方法

    在一些情况下，你不希望修改一个原有的类，但是你还想让他可以比较，Comparator接口可以实现这样的功能。通过使用Comparator接口，
    你可以针对其中特定的属性/字段来进行比较。比如，当我们要比较两个人的时候，我可能通过年龄比较、也可能通过身高比较。
    这种情况使用Comparable就无法实现（因为要实现Comparable接口，其中的compareTo方法只能有一个，无法实现多种比较）。

    如何实现集合排序?
    你可以使用有序集合，如 TreeSet 或 TreeMap，你也可以使用有顺序的的集合，如 list，然后通过 Collections.sort() 来排序。

    Map:
    ConcurrentHashMap是线程安全的hashmap，在多线程的情况下使用ConcurrentHashMap既能保证线程的安全，
    又能保证性能的最优，hashtable虽然也是线程安全的，可是在多线程的情况下效率低下。

    ConcurrentHashMap在发生冲突的时候和hashmap一样采用链地址法，可是ConcurrentHashMap又多了一种数据结构叫做Segment，
    每次线程访问的时候只锁其对应的segment，不用的segment可以并发执行。
    可以看出ConcurrentHashMap有点像把HashTable又包了一层, 把table放到了segments里,
    这样同步锁是在每一个segment里的, 只要多个修改操作发生在不同的段上, 它们就可以并发进行.
    我们为了区分, 把每个元素segment成为段(有的文章里称作桶), 把segment里面的table的单个元素成为桶.

    segments元素继承自reentrantLock，可以方便的进行锁操作，分段锁。
    hashMap:
    HashMap是数组+链表+红黑树
    链表长度大于8时转换为红黑树
    static class Node<K,V> implements Map.Entry<K,V>  {
    final int hash; //用来定位数组索引位置
    final K key;
    V value;
    Node<K,V> next; //链表的下一个node(为了解决hash碰撞的)

    Node是HashMap的一个内部类，实现了Map.Entry接口，本质是就是一个映射(键值对)。上图中的每个圆点就是一个Node对象。
    hashMap解决hash碰撞的问题用链地址法
    HashMap存储着Entry(hash, key, value, next)对象。
    put函数大致的思路为：
    对key的hashCode()做hash，然后再计算index;
    如果没碰撞直接放到bucket里；
    如果碰撞了，以链表的形式存在buckets后；
    如果碰撞导致链表过长(大于等于TREEIFY_THRESHOLD)，就把链表转换成红黑树；
    如果节点已经存在就替换old value(保证key的唯一性)
    如果bucket满了(超过load factor*current capacity)，就要resize。
    你知道get和put的原理吗？equals()和hashCode()的都有什么作用？
    通过对key的hashCode()进行hashing，并计算下标( n-1 & hash)，从而获得buckets的位置。
    如果产生碰撞，则利用key.equals()方法去链表或树中去查找对应的节点

    就是这个扩容的过程不是线程安全的，多线程操作时线程不安全
    扩容：如果bucket满了(超过load factor*current capacity)，就要resize。
    当hashmap中的元素个数超过数组大小loadFactor时，就会进行数组扩容，loadFactor的默认值为0.75，
    也就是说，默认情况下，数组大小为16，那么当hashmap中元素个数超过160.75=12的时候，就把数组的大小扩展为2*16=32，
    即扩大一倍，然后重新计算每个元素在数组中的位置，而这是一个非常消耗性能的操作，
    所以如果我们已经预知hashmap中元素的个数，那么预设元素的个数能够有效的提高hashmap的性能。

    Map接口有两个基本实现：
    --| HashMap 不能保证存取顺序，HashMap中使用键对象来计算hashcode值(内部是数组加链表)
    --| TreeMap 能保证存取顺序(内部是红黑树)
    --| LinkedHashMap LinkedHashMap是HashMap的一个子类，保存了记录的插入顺序，在用Iterator遍历LinkedHashMap时，
    先得到的记录肯定是先插入的，也可以在构造时带参数，按照访问次序排序。
    --| HashTable
    线程不安全：因为多线程环境下，使用HashMap进行put操作会引起死循环
    Collections的synchronizedMap方法使HashMap具有线程安全的能力，或者使用ConcurrentHashMap
    HashTable容器使用synchronized来保证线程安全效率较低
    不能保证存储的顺序性
    hashTable是遗留类，与hashMap类似，线程安全[HashTable实现线程同步是加了synchronized]
    在key未冲突的情况下，搜索的时间复杂度为o(1)
    默认容量16 加载因子0.75
    散列表（Hash table，也叫哈希表），是根据关键字（Key value）而直接访问在内存存储位置的数据结构。
    HashMap底层是个哈希表，使用拉链法解决冲突
    扩容是一个特别耗性能的操作，所以当程序员在使用HashMap的时候，估算map的大小，初始化的时候给一个大致的数值，避免map进行频繁的扩容。

    WeakHashMap与HashMap的区别是什么?
    WeakHashMap 的工作与正常的 HashMap 类似，但是使用弱引用作为 key，意思就是当 key 对象没有任何引用时，key/value 将会被回收。

    HashMap是非线程安全的，如果在多线程环境下，可以使用HashTable，HashTable中所有CRUD操作都是线程同步的，
    同样的，线程同步的代价就是效率变低了。

    再Java 5以后，有了一个线程安全的HashMap——ConcurrentHashMap，ConcurrentHashMap相对于HashTable来说，
    ConcurrentHashMap将hash表分为16个桶（默认值），诸如get,put,remove等常用操作只锁当前需要用到的桶。
    试想，原来只能一个线程进入，现在却能同时16个写线程进入（写线程才需要锁定，而读线程几乎不受限制，并发性的提升是显而易见。

    HashSet实现Set接口，不允许有重复[与List最大的不同，另外就是无序]，在对象存入set要先确保对象重写equals()和hashCode()方法[没实现的话走的是默认方法]。
    HashSet是基于HashMap实现的。

    不能保证存取顺序，因为HashSet内部使用的是HashMap,存储时是通过hash函数得到的下标。
    HashSet内部有一个HashMap的成员变量，我们在 HashSet 的构造函数中将其初始化，
    默认情况下采用的是 initial capacity为16，load factor 为 0.75。
    HashSet使用成员对象来计算hashcode值，对于两个对象来说hashcode可能相同，
    所以equals()方法用来判断对象的相等性，如果两个对象不同的话，那么返回false

    线程不同步：需要多线程访问它的话，可以用 Collections.synchronizedSet 方法来包装它

    LinkedHashMap
    继承关系
    public class LinkedHashMap<K,V> extends HashMap<K,V> implements Map<K,V>

    LinkedHashMap直接继承自HashMap，最大的不同是保证了存储的顺序性
    其实整体和HashMap类似，只不过通过节点中的before和after等属性维护了顺序。形成了双向链表。
    线程不安全
    同样是使用链表法来解决hash碰撞问题
    相比hashMap不同的就是节点的结构

    LinkedHashMap有个内部类Entry，这个Entry就是链表中的节点，继承自HashMap.Node，
    多出了2个属性before和after，所以LinkedHashMap内部链表的节点是双向的
    static class Entry<K,V> extends HashMap.Node<K,V> {
    Entry<K,V> before, after;
    Entry(int hash, K key, V value, Node<K,V> next) {
    super(hash, key, value, next);
    }
    }

    LinkedHashSet
    继承关系
    public class LinkedHashSet<E>
        extends HashSet<E>
        implements Set<E>, Cloneable, java.io.Serializable

        LinkedHashSet继自HashSet，但是内部的map是使用LinkedHashMap构造的，并且accessOrder为false，
        使用查询顺序。所以LinkedHashSet遍历的顺序就是插入顺序。

        与LinkedHashMap类似

        LinkList
        基于双向链表实现，链表无容量限制，不需要扩容，但双向链表本身使用了更多空间，也需要额外的链表指针操作。
        在链表中添加或删除元素很快，只需要O(1)的时间复杂度，适用于频繁增删的场景。在随机访问的方面不如Arraylist
        线程不安全,arrayList基于数组，linkList基于双向链表
        可添加null，可重复
        有序性

        内部类 实现双向链表结构 header表示链表的表头，Entry为节点对象

        List是Collection的子接口，它是一个元素有序(按照插入的顺序维护元素顺序)、可重复、可以为null的集合
        --|ArrayList
        --|LinkList

        public interface Map<K,V>  map接口
        Map接口中包含了一个keySet()方法，用于返回Map中所有key组成的Set集合。
        Map ：基于Map接口实现、允许null键/值、非同步、不保证有序(比如插入的顺序)、也不保证序不随时间变化。
        --| HashMap 基于hash表
        --| TreeMap 基于红黑树
        --| LinkedHashMap 有序的HashMap
        */

        public interface Set<E> extends Collection<E>
            public interface Collection<E> extends Iterable<E>
            set接口---》Collection接口---》Iterable接口

            Set接口通常表示一个集合，只是一个接口，其中的元素不允许重复，常用实现类有HashSet、LinkedHashSet和TreeSet。
            Set是Itreable---》Collection---》Set的接口（无序）。
            Set集合中的元素是唯一的，不可重复（取决于hashCode和equals方法），也就是说具有唯一性。
            Set集合中元素不保证存取顺序，并不存在索引。
            Set只是Map的一个马甲，主要逻辑都交给Map实现。

            看到array，就要想到角标。
            看到link，就要想到first，last。
            看到hash，就要想到hashCode，equals。
            看到tree，就要想到两个接口。Comparable，Comparator。

            Java中提供了两种对集合中元素排序的方法，一种是实现Comparable接口另一种是实现Comparator接口
            1、在实际的需求中，我们需要根据对象的各种属性(标题，时间，点击率，销售额...)进行排序(升序，降序)
            [当一个类希望使得自己的对象可以直接与其他的对象比较时，该类就应该去 implements(实现) Comparable接口]
            2、Comparator的应用场景，一般比较字符串是按照unicode的大小进行排序的
            [你可能不想或者不能去修改类的源代码。同时，你又希望可以基于对象的某些属性或字段去比较对象的大小，此时，我们就可以让该某类实现Comparator接口。]

            hashCode:
            public native int hashCode();
            它是一个本地方法，它的实现与本地机器有关。这里我们暂且认为他返回的是对象存储的物理位置（实际上不是，这里写是便于理解）。
            当我们向一个集合中添加某个元素，集合会首先调用 hashCode 方法，这样就可以直接定位它所存储的位置，若该处没有其他元素，
            则直接保存。若该处已经有元素存在，就调用 equals 方法来匹配这两个元素是否相同，相同则不存，不同则散列到其他位置

            整个处理流程是：
            1、判断两个对象的 hashcode 是否相等，若不等，则认为两个对象不等，完毕，若相等，则比较 equals。
            2、若两个对象的 equals 不等，则可以认为两个对象不等，否则认为他们相等。
            HashMap不保证数据有序，LinkedHashMap保证数据可以保持插入顺序，而如果我们希望Map可以保持key的大小顺序的时候，我们就需要利用TreeMap了。

            TreeMap继承自AbstractMap,内部使用红黑树(一种二叉树)结构实现元素存储。
            元素有序
            不允许Null的Key
            可以插入Null的Value
            Key重复的话会覆盖原来的Value
            线程不安全
            如果不需要有序性，建议使用hashMap

            1 继承关系
            public class TreeSet<E> extends AbstractSet<E>
            implements NavigableSet<E>, Cloneable, java.io.Serializable

            public interface NavigableSet<E> extends SortedSet<E>

                与 HashSet 是基于 HashMap 实现一样，TreeSet 同样是基于 TreeMap 实现的

                ### Collection
                一个 Collection 代表了一堆对象的集合体
                边遍历边修改Collection的唯一正确方式是使用Iterator.remove()方法
                Java里有很多方法来维持一个collection有序。有的需要实现Comparable接口，有的需要自己指定Comparator。
                它是Java集合框架的一个根接口，也是List、Set和Queue接口的父接口。同时它定义了可用于操作List、Set和Queue的方法—增删改查。

                hash表原理?
                HashMap是Map的一个常用的子类实现。其实使用散列算法实现的。 HashMap内部维护着一个散列数组(就是一个存放元素的数组)，我们称其为散列桶，而当我们向HashMap中存入一组键值对时，HashMap首先获取key这个对象的hashcode()方法的返回值，然后使用该值进行一个散列算法，得出一个数字，这个数字就是这组键值对要存入散列数组中的下标位置。 那么得知了下标位置后，HashMap还会查看散列数组当前位置是否包含该元素。（这里要注意的是，散列数组中每个元素并非是直接存储键值对的，而是存入了一个链表，这个链表中的每个节点才是真实保存这组键值对的。）检查是否包含该元素时根据当前要存入的key在当前散列数组对应位置中的链表里是否已经包含这个key,若不包含则将这组键值对存入链表，否则就替换value。 那么在获取元素时，HashMap同样先根据key的hashcode值进行散列算法，找到它在散列数组中的位置，然后遍历该位置的链表，找到该key所对应的value之后返回。 看到这里可能有个疑问，链表中应该只能存入一个元素，那么HashMap是如何将key-value存入链表的某个节点的呢？实际上，HashMap会将每组键值对封装为一个Entry的实例，然后将该实例存入链表。

                什么是迭代器(Iterator)？
                Iterator接口提供了很多对集合元素进行迭代的方法。每一个集合类都包含了可以返回迭代器实例的
                迭代方法。迭代器可以在迭代的过程中删除底层集合的元素。

                有没有可能两个不相等的对象有有相同的 hashcode？
                有可能，两个不相等的对象可能会有相同的 hashcode 值，这就是为什么在 hashmap 中会有冲突。相等 hashcode 值的规定只是说如果两个对象相等，必须有相同的hashcode 值，但是没有关于不相等对象的任何规定。

                两个相同的对象会有不同的的 hash code 吗？
                不能，根据 hash code 的规定，这是不可能的。

                Java 中，Comparator 与 Comparable 有什么不同？
                Comparable 接口用于定义对象的自然顺序，而 comparator 通常用于定义用户定制的顺序。Comparable 总是只有一个，但是可以有多个 comparator 来定义对象的顺序。

                Comparable和Comparator接口是干什么的？列出它们的区别。
                Java提供了只包含一个compareTo()方法的Comparable接口。这个方法可以个给两个对象排序。具体来说，它返回负数，0，正数来表明输入对象小于，等于，大于已经存在的对象。
                Java提供了包含compare()和equals()两个方法的Comparator接口。compare()方法用来给两个输入参数排序，返回负数，0，正数表明第一个参数是小于，等于，大于第二个参数。equals()方法需要一个对象作为参数，它用来决定输入参数是否和comparator相等。只有当输入参数也是一个comparator并且输入参数和当前comparator的排序结果是相同的时候，这个方法才返回true。

                为什么在重写 equals 方法的时候需要重写 hashCode 方法？
                因为有强制的规范指定需要同时重写 hashcode 与 equal 是方法，许多容器类，如 HashMap、HashSet 都依赖于 hashcode 与 equals 的规定。

                用哪两种方式来实现集合的排序？
                你可以使用有序集合，如 TreeSet 或 TreeMap，你也可以使用有顺序的的集合，如 list，然后通过 Collections.sort() 来排序。

                List、Set、Map是否继承自Collection接口？
                答：List、Set 是，Map 不是。Map是键值对映射容器，与List和Set有明显的区别，而Set存储的零散的元素且不允许有重复元素（数学中的集合也是如此），List是线性结构的容器，适用于按数值索引访问元素的情形

                ## List
                List：元素能够重复，有顺序即索引位置，在Collection的基础上提供了按照索引位置进行操作的方法

                Collections.sort()可以用来对list排序。该排序是稳定的，并且可以保证nlog(n)的性能。

                ①List是元素有序并且可以重复的集合。
                ②List可以精确的控制每个元素的插入位置，或删除某个元素的位置。
                Comparator接口：临时的比较规则。如果某一个类要实现这个接口，那必然要实现它的Compare()方法。
                Comparable接口：默认的比较规则。当实现了这个接口，则表示这个类的实例可以比较大小，可以进行自然排序。如果某一个类要实现这个接口，那必然要实现它的CompareTo()方法。

                ### ArrayList
                ArrayList的数据结构
                数组结构，允许重复数据，取值快，插入慢
                ArrrayList 底层的数据结构是数组，支持随机访问

                什么时候用ArrayList？
                ArrayList是使用数组实现的list，本质上就是数组。ArrayList中的元素可以通过索引随机获取一个元素。但是如果该数组已满，当添加新元素时需要分配一个新的数组然后将原来数组的元素移动过去，需要O(n)的时间复杂度。添加或删除一个元素需要移动数组中的其他元素。这是ArrayList最大的缺点。

                写一段代码在遍历 ArrayList 时移除一个元素？
                该问题的关键在于面试者使用的是 ArrayList 的 remove() 还是 Iterator 的 remove()方法。这有一段示例代码，是使用正确的方式来实现在遍历的过程中移除元素，而不会出现 ConcurrentModificationException 异常的示例代码。

                ### Vector
                类似ArrayList但线程安全。大部分方法都使用了Synchronized同步。所以会很影响性能。

                ### LinkedList
                LinkedList是一个双向链表。因此，当需要获取list中某个元素，需要从头到尾遍历list。另一方面，在链表中添加或删除元素很快，只需要O(1)的时间复杂度。从空间上来说，在链表中一个节点需要两个额外的指针来指向它的previous和next节点。
                频繁插入删除元素用LinkedList 实现更好。
                LinkedList 的底层数据结构书链表，不支持随机访问

                ### Map
                键值对的集合，key不能重复，value可以重复

                ### HashMap
                HashMap的数据结构为数组加单链表结构。不允许有相同的key允许null为key，null为key的时候值是保存下了数组下标为0中。可以有相同的value。
                和HashSet集合不能保证元素的顺序一样，HashMap也不能保证key-value对的顺序。同时判断标准也一样：两个key通过equals方法比较返回true、同时两个key的hashcode值也必须相等。

                HashMap的工作原理
                HashMap内部是通过一个数组实现的，只是这个数组比较特殊，数组里存储的元素是一个Entry实体(jdk 8为Node)，这个Entry实体主要包含key、value以及一个指向自身的next指针。HashMap是基于hashing实现的，当我们进行put操作时，根据传递的key值得到它的hashcode，然后再用这个hashcode与数组的长度进行模运算，得到一个int值，就是Entry要存储在数组的位置（下标）；当通过get方法获取指定key的值时，会根据这个key算出它的hash值（数组下标），根据这个hash值获取数组下标对应的Entry，然后判断Entry里的key，hash值或者通过equals()比较是否与要查找的相同，如果相同，返回value，否则的话，遍历该链表（有可能就只有一个Entry，此时直接返回null），直到找到为止，否则返回null。
                HashMap之所以在每个数组元素存储的是一个链表，是为了解决hash冲突问题，当两个对象的hash值相等时，那么一个位置肯定是放不下两个值的，于是hashmap采用链表来解决这种冲突，hash值相等的两个元素会形成一个链表。

                HashMap与HashTable的区别
                HashTable基于Dictionary类，而HashMap是基于AbstractMap。Dictionary是任何可将键映射到相应值的类的抽象父类，而AbstractMap是基于Map接口的实现，它以最大限度地减少实现此接口所需的工作。
                HashMap的key和value都允许为null，而Hashtable的key和value都不允许为null。HashMap遇到key为null的时候，调用putForNullKey方法进行处理，而对value没有处理；Hashtable遇到null，直接返回NullPointerException。
                Hashtable是同步的，而HashMap是非同步的，HashMap更适合于单线程环境，而Hashtable适合于多线程环境。但是我们也可以通过Collections.synchronizedMap(hashMap),使其实现同步。

                ### LinkedHashMap
                LinkedHashMap的实现原理
                LinkedHashMap也是基于HashMap实现的，不同的是它定义了一个Entry header，这个header不是放在Table里，它是额外独立出来的。LinkedHashMap通过继承hashMap中的Entry,并添加两个属性Entry before,after,和header结合起来组成一个双向链表，来实现按插入顺序或访问顺序排序。LinkedHashMap定义了排序模式accessOrder，该属性为boolean型变量，对于访问顺序，为true；对于插入顺序，则为false。一般情况下，不必指定排序模式，其迭代顺序即为默认为插入顺序。

                ### TreeMap
                线程不同步，基于 红黑树 （Red-Black tree）的NavigableMap 实现，能够把它保存的记录根据键排序,默认是按键值的升序排序，也可以指定排序的比较器，当用Iterator 遍历TreeMap时，得到的记录是排过序的。

                ### HashTable
                Hashtable 与 HashMap 有什么不同之处?
                这两个类有许多不同的地方，下面列出了一部分： a) Hashtable 是 JDK 1 遗留下来的类，而 HashMap 是后来增加的。 b）Hashtable 是同步的，比较慢，但 HashMap 没有同步策略，所以会更快。 c）Hashtable 不允许有个空的 key，但是 HashMap 允许出现一个 null key。 更多的不同之处参见答案。
                HashTable：线程安全，HashMap的迭代器(Iterator)是fail-fast迭代器。HashTable不能存储NULL的key和value。

                ### Set
                元素不能重复，没有顺序
                Set集合类似于一个罐子，丢进Set集合的对象间没有明显的顺序，Set继承Collection接口，不能包含有重复元素。 Set判断两个对象是否相同是通过equals方法，而不是“==”比较符，也就是说，加入一个新元素时。必须和所有已有对象进行equals返回false；

                ### HashSet
                HashSet的数据结构不允许有相同的值，无序的，优势在于查找相同元素的时候时间复杂度为最低.根据hashCode判断对象是否重复(重写equals和hashCode)
                HashSet有以下特点
                1、不能保证元素的排列顺序，顺序有可能发生变化
                2、不是同步的
                3、集合元素可以是null,但只能放入一个null
                当向HashSet结合中存入一个元素时，HashSet会调用该对象的hashCode()方法来得到该对象的hashCode值，
                然后根据 hashCode值来决定该对象在HashSet中存储位置。

                HashSet的底层实现是什么
                通过看源码知道HashSet的实现是依赖于HashMap的，HashSet的值都是存储在HashMap中的。在HashSet的构造法中会初始化一个HashMap对象，HashSet不允许值重复，因此，HashSet的值是作为HashMap的key存储在HashMap中的，当存储的值已经存在时返回false。

                Java 中的 HashSet，内部是如何工作的？
                HashSet 的内部采用 HashMap来实现。由于 Map 需要 key 和 value，所以所有 key 的都有一个默认 value。类似于 HashMap，HashSet 不允许重复的 key，只允许有一个null key，意思就是 HashSet 中只允许存储一个 null 对象。

                HashSet和TreeSet有什么区别？
                HashSet是由一个hash表来实现的，因此，它的元素是无序的。add()，remove()，contains()方法的时间复杂度是O(1)。
                另一方面，TreeSet是由一个树形的结构来实现的，它里面的元素是有序的。因此，add()，remove()，contains()方法的时间复杂度是O(logn)。

                ### TreeSet
                TreeSet:TreeSet实现SortSet接口,里面的元素按顺序排列（素必须实现Comparable接口）
